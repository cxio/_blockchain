//////////////////////////////////////////////////////////////////////////////
Copyright (c) 2019 - 2023 @cxio/blockchain

    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.3
    or any later version published by the Free Software Foundation;
    with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
    A copy of the license is included in the section entitled "GNU
    Free Documentation License".
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


## 端点约定

在P2P的世界里，不同于传统的「服务器/客户端」的主从逻辑，相互连接的端点是一个平等的关系。端点既是客户端也是服务器，两个端点依靠预先定义的规则对等交互、协作，共同构成了自由的点对点网络，这是一个由契约维系的去中心化的世界。

所有的端点都遵循共同的规则或约定，这些规则和约定，我们可以称之为 **端点约定**。

端点约定没有强制力，P2P是自由的，端点也有不遵守约定的自由。但这样的约定会在现实中形成一道屏障：你可以不遵守规则、破坏约定，但别人会离你而去……当大家都不理你了，你就脱离了这个世界，变得无足轻重。因此，端点约定其实是有很强的现实约束力的，即便它并没有强制你。


### 两种层级

端点约定有两种：

- 一种需要严格遵守，完整并明确，通常处于端点的实时交互中，称之为**协议**。这是一个通用的概念，这里不再赘述。
- 一种是宽松的公共守则，如果都遵守，系统会运作得更好，但不遵守也不会带来太大问题。比如大家都在相同的时间做同一件事，这可以称之为**约定**。

> **注：**
> 在网络语境中，端点有时也称为节点，在下面的叙述中并不刻意区分两者。



## 分叉竞争

虽然通过择优池可以获得很好的确定性，但那并不能保证区块链绝不出现分叉。如果择优池中的高权重者没有按时出块，或者网络原因导致了优质区块的隔离，又或者有私自挖矿的攻击，分叉就可能出现。


### 实时评估

本设计采用固定的出块时间，没有Bitcoi中最长链的逻辑，因此评估区块权重其实就是对比区块中的择优凭证（其存储在 `CoinBase` 交易内）。

如果网络中出现了当前高度的一个新区块（节点间会实时通知），我们需要逆向查找它的分叉点：

- 如果分叉点已在 `-11号` 评考区块及之前（过去），则简单忽略。因为那已经是另一条区块链了，与本链无关。
- 如果分叉点就是上一个区块，我们只需要简单验证对比各自的择优凭证，值优者胜出。
- 如果分叉点在评考区块之后（未来），分支上不止一个区块，则需要将择优权重累加后对比（当然在逐一验证之后）。

多个区块累计后再对比，可以避免攻击者因偶尔获得单个优质区块后，就拥有了决定性的影响力。


#### 附：区块头结构（`80+32`）

```go
BlockHeader: {
    Version   uint32    // 协议版本
    PrevBlock [32]byte  // 前一区块哈希
    YearBlock [32]byte  // 前一年块哈希（height % 87661 == 0 有效）
    Height    uint32    // 区块高度
    CheckRoot [32]byte  // 校验根（类似Bitcoin里的MerkleRoot）
    Stakes    uint32    // 币权销毁（单位：币天）
    Phases    uint32    // 择优权重（X信息）
}
```

其中的年块指从创始区块开始，每年引用一次形成年块链。主要用于附生侧链对主链的引用，或快速验证很长的链段，比如整条区块链。

存储币权销毁主要是方便统计类的外部分析工作，它能比较好地反映链上交易的真实信息。



## 交易的传输

区块是交易的集合，交易的传输影响着铸造者们对交易的期望以及区块的内容。一位贪婪的铸造者可能试图等待尽量多的交易而影响出块时间，而交易时间戳的任意性也会让时间戳缺乏意义。为了某种有序化，需要设计如下规则。


### 适时转播

交易的时间戳与节点本地的时间相比较，如果它属于未来，这笔交易就称为 **未来交易**，区块不收录未来的交易（相对于出块时间点），但定义交易时间戳在未来是允许的，它们只是暂时处于链外，类似于Bitcoin中交易的链外锁定。

这些交易会被正常的校验和转播，但有一个例外：**当前区块时段内的** 未来交易不立即转播，节点应等待时间到达后才转播出去，这就是「适时转播」。

这一约定主要用于配合零确认的安全机制，确保双花交易只在恰当的时间可见（详见后）。

> **注：**<br>
> 未来交易可能无法绑定相应的-11号区块，历史标记位应当置零。这不影响收录，但会失去铸造资格。


### 错时延迟

当一笔交易传播至节点时，交易的时间戳可能晚于（小于）当前节点的实际时间，如果这一差距较大，就称这是一笔**错时交易**。区块可以收录错时的交易（它们属于过去），但这些错时交易可能成为铸造者贪婪的诱饵，影响他们按时出块，所以这里设计了一个约定：

**当出块时间到达后，时间戳在出块时间之前的错时交易会被暂停转播，直到该区块被创建、广播并确定下来**，之后再恢复这些交易的传输。这就是「错时延迟」。对于区块铸造者来说，时间到了，就没有可打包的新交易传输过来了，所以就没必要等待，按时出块即可。


### 设计要点

> 当前区块时段内的未来交易应当等到时间到达后才转播。这是零确认安全的前置措施。<br>
> 按时间计算，在最新区块时间戳之前的交易（已错时）会被暂停传播，以避免铸造者的贪婪等待。<br>



## 区块的结构和同步

逻辑上，区块只是一个抽象容器，包含交易的索引用于检索交易数据本身。交易索引由 `32字节的交易ID + 4字节的序位` 构成，它们在区块里有序排列，让区块的构造拥有一种确定性。

末尾的4字节序位是实际存在的，可用于辅助验证第三方**区块查询服务**提供的数据：交易的输入源由**区块高度**、区块中交易的**序位**和脚本在输出集内的**偏移位**构成，因此验证第三方是否按序位提供数据，就需要此处的索引中包含序位。

**验证：**
> 第三方服务根据客户提供的**区块高度**、**交易序位**和**输出偏移位**向客户提供*交易数据*和*验证树哈希集*，
> 客户计算交易数据得到**交易ID**，附加交易序位构造**索引**，结合服务方提供的验证树哈希集，就可以计算四元链哈希树的根哈希，从而完成验证。


### 四元链哈希树

本设计中采用默克尔树类似功能的四元链哈希校验树结构，如下。

<img src="images/list4th-1050x700.png" width="1050" alt="四元链哈希树结构" />

**说明：**
- 平行的链式结构方便逐层或跨层地提取哈希值，实现快速的交互对比。
- 最末端的交易索引叶子节点依然可以简单定位，整个序列有序排列。
- 该哈希树仅在最终出块时构建，并不用于内存结构中动态插入交易信息。


### 区块的同步

区块可能包含大量的交易，假设有64k笔，则区块所涉及的数据可能达数十上百兆。这使得在一个较短的区块时段内传输全部数据较为困难，或者是不可靠。

但实际上事情并没有那么糟糕，因为如果节点一直在线，区块所涉及的交易大多已经被节点收集和验证了（数据已经存在）。区块之所以需要同步，是因为铸造者打包了它，而铸造者收集的交易集可能稍有不同。所以，区块同步实际上只需要厘清并补足那些少量差异的部分，然后节点自行构造区块即可。


### 设计要点

> 区块同步只需要对比发现不同的部分然后补足即可，交易ID在区块内的有序排列是一种确定性约束。<br>
> 区块的发布只需要包含必要的可验证数据，实现快速广播。之后再同步交易数据。<br>
> 四元链哈希树被用于构造区块验证（区块头内的校验根）和历史区块对比下载、第三方交易数据验证等用途。<br>



## 零确认的安全性

交易在网络上的传输没有先后顺序，原则上，交易一旦广播出去便无法撤回。如果存在双花的交易，铸造者会优先打包时间戳更早的交易（暂不考虑交易费问题），这是一个简单的约定，也是零确认安全机制的前提。

攻击者可以构造两笔相同输入源的双花交易，其中一笔时间戳更早（可能交易费也更高）但晚一点发送。如果接收者认可零确认，在收到前一笔交易后发货或让顾客拿货离开，但最终进入区块的却是后一笔交易。这会让零确认的安全无法实行。

不过，借助于更精细的一些规则设计，我们可以很大程度上避免这种攻击行为。

> **注：**<br>
> 零确认安全有一个时间上的阈值，这里的设计是1分钟。即：收款方需要等待至少1分钟才能确认安全。
> 零确认安全只是一种简单设计，应当只用在小额收款上，大额交易应当等待真正的区块确认。


### 时序保障

双花交易可能来自于用户的纠错行为：发送一笔交易后发现失误，立即重构一笔新交易发出。这是允许的，但有一些约束。

1. 更正交易需要设置为更早的时间戳。考虑可靠性，交易费不应当低于前一笔失误交易。
2. 更正交易需要在失误交易发送后1分钟之内发出。这是一个规定阈值，否则更正交易会被丢弃。

对于一个中转节点来说，接收到交易验证合法后会存储到内存池中，同时也需要记录交易的实际收到时间（注：可以是与交易时间戳的差值）。如果发现新收到的交易是一笔双花交易，它们根据下面的规则行事。

1. 如果新交易的时间戳更晚（值更大），则忽略丢弃。因为区块应当收录更早的交易。
2. 如果新交易的时间戳更早（值更小），则检查时间戳与当前实际时间的误差：1分钟内视为更正交易正常转播，否则视为双花攻击丢弃。
3. 如果新交易的时间戳与原交易相同，则检查原交易的实际收录时间，如果在1分钟之内，也视为正常的更正交易转播，否则视为双花攻击丢弃。

> **注：**<br>
> 阈值之内的双花交易可以被铸造者观察到，收录较早交易只是一个松约束（可自由裁定）。


#### 攻击分析

**攻击：**

- 方式：前一笔交易提前发送，但时间戳设置得比较晚（值大），后一笔交易晚发送，但时间戳设置得比较早（值小）。
- 目的：希望前一笔交易被商家认可，但区块实际收录后一笔交易。
- 约束：两笔双花交易的实际发送时间差需要大于 `1分钟`，因为商家会要求等待1分钟以上（安全阈值）。

**分析：**

1. 前一笔交易的时间戳如果晚于实际时间，会被「适时转播」规则阻塞，因此商家并不会提前看到这一笔交易。
2. 前一笔交易的时间戳如果早于当前实际时间，转播不受影响，但第二笔交易的时间戳必须更早，如果时差超过阈值，则会被「时序保障」规则滤掉。
3. 如果两笔交易的时间戳相等，交易的传播受实际收录时间相差1分钟的阈值保护，这也不会有问题。

**结论：**

1. 双花的第二笔交易广播时间超出阈值后，实际上很难广播出去，所以铸造者很难收到第二笔交易。
2. 收款者收到一笔支付后，稍微等待一段时间（1分钟+），就可以看到是否存在双花的情况，然后自行处理。


### 最低交易费

交易费是矿工的重要收入来源，提供服务收取费用是一种正常的逻辑。区块收录交易的数量是有限的，因此交易费的高低源于市场的驱动，不过一个恰当的最低交易费规则是有益的。

铸币的资格源于历史的交易，最低交易费可提高仅仅为铸造资格而构造大量细微交易的成本。另外，如果没有此规则，太低的交易费可能导致铸造者长期不收录它们，弃置太久的交易会最终失效（2天），这瓦解了零确认的安全性（**解**：接受零确认交易的收款方可提出交易费要求）。

最低交易费由前期的平均交易费计算而来：系统每 `24000个` 区块（100天）统计一次，取平均值的 `1/4` 作为当前阶段的最低交易费。

注意，这只是一个端点间约定而不是交易协议，各个端点检查统计交易费情况，自行决定自己的交易费检查策略。



#### 附：交易过期

未被收录的交易超过一定时间后会作废，这个期限设计为2天（`480个` 区块）。过期是按交易的时间戳和当前时间对比判断的，它的意义在于：

1. 缩减未确认交易的规模。
2. 提升时间因子的价值，为某些应用提供条件。

人们不应当期待一笔超过2天都未完成（确认）的交易依然有效，漫长的期待实际上也有一种负面的心理效应。


### 设计要点

> 铸造者优先打包时间戳更早的交易，这是处理双花交易的基本规则，但它是一个宽松约束。<br>
> 交易更正有一个 `1分钟` 的时间容度（阈值），超过之后的交易将被视为双花攻击而被阻塞。<br>
> 收款方如果认可零确认交易，应当等待至少 `1分钟` 以发现是否存在双花攻击。<br>
> 最低交易费采用前期 `24000个` 区块平均交易费的 `1/4` 作为当前阶段的值，但这只是一个约定。<br>
> 长时间游离于链外的交易会过期，按时间戳计算超过2天 `480个` 区块时段即为失效。<br>



-------------------------------------------------------------------------------

上一篇：[共识模型-概率证明（PoP）](1.共识模型-概率证明（PoP）.md)<br>
下一篇：[公共服务](3.公共服务.md)<br>
