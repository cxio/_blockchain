## 批量付款确认

### 用例

前期支付不可花费，需要等待后期的一次确认。等待确认的支付可以不止一个，但都用同一个确认。
（注：前期支付后，付款者就不能再使用那笔资金了）

**条件：**
> 付款和收款双方共同构造一个双重签名地址（1/2模式），任一签名皆可使用。<br>
> 双重签名的公钥地址序列假设为「付-收」序（即：[0] = 付款者，[1] = 收款者）。<br>


### 原理

- 前期的支付是有效付款（已进入区块），但是脚本中存在一个哈希屏障，而哈希源有后期的确认交易提供。
- 为了可以取消前期的支付，需要植入一个过期赎回的逻辑。


### 脚本

**前期支付交易：**

```go
// 解锁参数
// <sig> <pubKey>                   // 系统内置验证

// 确认交易定位信息：
// 理想块高度、交易ID、输出索引。收款者提供。
<Height> <TxID> <OutIndex>

// 锁定脚本
SYS_TIME{Stamp} {<expireTime>} GT   // 是否过期
IF{                                 // 是：
    MULSIG[0] PASS                  // 由付款方签名，赎回通过
    EXIT                            // 结束脚本
}                                   // 否：
JUMP                                // 跳转取值（哈希源）
FN_HASH256 DATA{<hashResult>} EQUAL // 哈希屏障
MULSIG[1]                           // 是否由收款方签名
BOTH PASS                           // 前两者都为真时通过（收款方使用转移）
```


**后期确认交易：**（输出类型字段置位「中介管理」）

```go
{<hashSource>}  // 简单提供哈希源即可（需由 JUMP 指令跳转）。
```


### 优点

支付实际上已经发生，付款者的币金已经转移（公共可见）。收款者只是因为暂时无法使用，而让币金被冻结了。这样的冻结可以给付款者一个审核所有前期支付的机会，预防出错或满足其它需要。这在某些场景下可能很有用。

> **注意：**<br>
> 为了让收款者有充分的时间进行币金转移，确认交易应当尽量提前，或有效期足够长。<br>
> 因为有效期过后，付款者已经可以赎回，虽然收款者依然可以继续使用，但这合常理吗？<br>
