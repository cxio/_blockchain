//////////////////////////////////////////////////////////////////////////////
Copyright (c) 2019 @cxio/blockchain

    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.3
    or any later version published by the Free Software Foundation;
    with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
    A copy of the license is included in the section entitled "GNU
    Free Documentation License".
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


## 攻击与安全

### 网络干扰

匿名开发者做出一个破坏端点约定的客户端，组织运营以破坏良好的网络协作是可能的。匿名可以避免法律诉讼，因此法律手段不足以解决问题。这需要借助于端点评估来对抗，具体分如下两种情况：

1. 普通违约。客户端发现对方违反普通的宽松约定时，及时回馈、阻断违约、降低等级，暂不断开连接。
2. 违反协议。客户端发现对方违反合法性规则协议，可将之视为攻击，断开连接（加入临时的黑名单）。

**说明：**
普通的违约可能来自于某种失误，网络应当对它们保持一定的容忍，保持连接但阻断违约扩散。行为会被记录，如果多次不改则应当断开连接。



### 哈希屏障

面对极其强大的计算能力，非对称签名的安全性可能并不足够，但哈希碰撞的难度却可以简单升级。隐藏计算哈希摘要的源数据，设置一个对比哈希摘要的验证，就是一种安全屏障。本系统中称之为「哈希屏障」。Bitcoin中账户地址对公钥的隐藏，就是这种安全措施的设计。

> **注：**<br>
> 假设量子计算机开始投入使用，256位的哈希算法无法抵挡时，系统更容易升级到512位或更高。<br>


### 历史分叉

攻击者从古老的历史结点分叉出一条支链，与主链竞争废除或扰乱之后的历史交易，是一种必须排除的风险。Bitcoin系统中是采用哈希工作量难度的积累来避免，简单而直接。本设计中则包含了如下综合性措施，它们也是系统本身的构成部分。

**1. 共识模型里的历史约束**

区块的共识算法是从历史交易中评选铸造者，这使得合法性有了时间上的延伸性，即：铸造者必然从历史中来，如果想要分叉，初始阶段必须寻求原始主链合法历史中的交易者支持。

因为哈希结果的随机性，拥有高权重铸造资格的交易也是随机的，攻击者寻找这些交易的拥有者并不容易，而让他们参与合谋也是需要诱惑的。公开的招揽或寻找曾有大量铸造委托的服务商合谋是一个捷径，但这依然有成本并且可能违法。

**2. 历史标记的主链锁定**

交易头中有20字节用于匹配交易时间戳之前-11号区块的哈希，这实现了交易与主链的绑定，使得攻击者无法借用主链上的铸造资源。如果分叉支链上的交易数量和质量不足够，支链就形不成强大的竞争力，而如果想要解决这个问题，攻击支链就需要广泛的同谋支持，或者攻击者自己就掌控足够的资源。

系统设计为当前链末端20万区块内的交易可参与铸造竞争，如果假设每区块64k笔交易，竞争者规模可达百亿量级。这是一个庞大的基数，攻击者掌控足够的比例应该极其困难甚至不可能。

**3. 客户端主链绑定的限制**

客户端会对当前主链进行绑定，这会引入社会性的共识约束：现存的客户端都已经确认了它们的主链，只有定制的攻击客户端才会支持从古老结点分叉出来的分支。这样的攻击客户端有多少用户呢？

另外，本设计中主链的评估实际上并不支持切换到古老的分支，攻击支链也不会得到现存客户端的支持。

**4. 公共服务网络的外部性**

区块查询是一个公共服务网络，因为UTXO指纹的设计使得当前最新链段很容易验证。如果攻击者想发展出一条古老分支，也同样需要得到公共服务网络的支持，或者说，攻击者需要同时攻击或利诱公共服务的节点们。

总的来看，如果分叉很难对主链造成干扰，它就缺乏价值支撑（攻击的价值），最终的不兼容，只是出现了两个不同的系统而已。

#### 解锁数据的可删除性

如果上面的后3条足以保证主链不受干扰，实际上古老历史交易里的解锁数据就是可有可无的。解锁数据只是为了验证交易输入的合法性，当交易已经构造并进入区块固化后，交易的安全可靠就由区块链自身来保护了。

删除古老历史交易里的解锁数据是安全的，能节省了很多空间。这也是本设计中交易ID不计算解锁数据的原因。

> **注：**
> 这是区块链固定出块时间的优点，因为在客户端锁定固化或超越支链竞争环节之后，区块链就无需分辨谁是主链了。
> 而按出块快慢无限竞争类的区块链，逻辑上是无法删除解锁信息的（虽然现实可行）。


### 交易延展性攻击

Bitcoin 中的交易ID包含了签名的数据，而合法的签名并不唯一，因此交易ID就有了可变性。这不会改变交易的输入和输出定义，但会给一些应用带来问题。

问题来源于签名数据的可变性，但实际上签名与交易的定义是两个不同的逻辑，交易如果已经验证并固化下来，它的合法性就由区块链保证了。之所以需要保留签名数据，是为了防止区块链被重建（从而根本上造成破坏），但如果区块链本身已经有了其它安全保障并足够，那这些签名就是可有可无的了。

本设计中交易ID的计算并不包含签名数据，签名数据是附着在交易数据之后一起广播，客户端和公共服务网络只是使用签名数据验证并适当存储。这样交易的延展性问题就不再存在了。


> ### 附注：
> 本文的内容并不充分，攻击和安全的问题需要在项目发展过程中收集和讨论。本文档暂不重要，仅附带而已。



-------------------------------------------------------------------------------

上一篇：[附1：组队校验](附1.组队校验.md)<br>
下一篇：[附3：概念集](附3.概念集.md)<br>
