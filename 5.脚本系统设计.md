//////////////////////////////////////////////////////////////////////////////
Copyright (c) 2019 - 2022 @cxio/blockchain

    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.3
    or any later version published by the Free Software Foundation;
    with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
    A copy of the license is included in the section entitled "GNU
    Free Documentation License".
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


## 概述

交易是信用呈现和转移的一个包装单元，除了必要的基本信息外，一笔交易中主要包含输入和输出两个部分。输入表达的是信用来源（由另一笔交易的输出定义），输出表达信用转移的目的地（由信用值如金额和一个可执行的锁定脚本构成）。

用户之所以能够使用另一笔交易的输出来作为本次交易的输入，是因为他或她能提供那一笔交易输出里锁定脚本的解锁证明，让本次交易验证里可以成功执行上一笔交易输出里的锁定脚本。这就是区块链交易的验证逻辑。

> **注：**
> 下文中的代码并非Go语言代码，仅是借语法颜色以获得良好显示。



## 三种基本信元

在本设计中，信用的数字表达有三个：**币金**、**凭信** 和 **证据**，它们可被称为「信元」。币金是可拆分的数值，类似货币；凭信是不可拆分的文本或二进制数据，类似契约、债券或与实物绑定的数字凭证；证据则是一种存在性表达，可能是文本也可能是二进制数据，不可拆分也不能转移。

如果一笔交易里的输入项全部是币金，这就是一笔纯粹的转账交易，如果还包含有凭信或证据，就是一笔混合交易。仅仅包含凭信或证据的交易虽然逻辑上没有问题，但交易上链是需要交易费的（打包交易的矿工需要激励），因此必须要有币金信元的输入（注：币金输入与输出的差值即为交易费——矿工计算验证后即可创建等额的新币归自己所有）。

锁定脚本由指令序列构成，包含：数据定义、流程控制、算术运算、条件对比、对外交互、以及功能性函数指令等。解锁证明也是一段指令序列，俗称解锁脚本或解锁参数，通常只是数据定义和变量设置。

脚本依然沿用Bitcoin区块链中的**栈结构**设计：一个初始的空栈用于暂存指令的实参，每一个指令执行的结果又被压入栈中，为后续指令提供参数数据。栈是后进先出（LIFO）的逻辑，出于安全和性能的考虑，脚本有长度和执行时间的限制。

不同于Bitcoin系统中的脚本指令规则，这里进行了较多的扩展，以期获得完整的编程逻辑。


### 币金

数字化的信用单位，表达具体额度的价值，类似于货币或金钱，有时也被称为代币或Token。因为是数值，所以可以执行算术逻辑，分割或合并。接收币金的通常都是一个标准地址，出于优化，解锁会默认执行前置的签名验证，即验证指令序列无需书写在锁定脚本里。

> **注：**<br>
> 接收者也可以是非标准的任意目标，此时则无法应用标准的内置验证。<br>

币金的生成只能由区块的铸造者完成（铸币），币金的转移交易则是任何人都可以创建的。


#### 接收者

如果是采用系统内置的默认验证，接收者需要是标准的格式地址。

标准的地址包含2种：

1. **P2SA**: 即 `Pay to Single Address`，同Bitcoin中的 `P2PKH`。这里交易数据中实际存储的是公钥哈希地址（简称*公钥地址*）。
2. **P2MA**: 即 `Pay to Multiple Address`，支付到多重签名地址。同上，交易数据中存储的也是多重签名的公钥地址。详情见下 *多重签名*。

如果采用定制验证，接收者是可选的，但一个友好的名称通常也很不错。名称长度有1字节大小限制（<256字节）。

Bitcoin 中的 `P2SH (Pay to Script Hash)` 在 Bitcoin 系统中主要用于多重签名，但实际上它是一种通用逻辑。这里，我们把多重签名的概念提取出来，作为一种预定义的标准格式处理。

在本设计中，`P2SH` 属于定制验证的范畴（详情见后）。

> **注：**
> 本设计拥有丰富灵活的栈脚本语法环境，可用于复杂的信用逻辑编程，因此多重签名也需要独立出来。


#### 数量

一个变长的整数值，表达币金的数量。单位为「聪」（纪念Bitcoin创世者中本聪）。


#### 锁定脚本

控制当前交易输出的币金可以被谁使用。注：即作为下一笔新交易的输入，如果用户提供的解锁脚本使得锁定脚本成功执行通过，则该笔币金就花了出去。


### 凭信

信用凭据的数字化表达，代表某种特定的价值或承诺，可转让或修订。与币金信元不同，除了接收者外，还有创建者、描述和附件ID几个字段。

凭信转移也可被视为 **花费**，与币金一样，未花费的凭信会进入 `UTXO` 集。


#### 接收者

与币金的接收者规则相同。


#### 创建者

用该凭信交易的交易ID（可能还有区块号）表示。创建泛指：初次创建、修订创建、转为不可修改模式。

与币金只能由区块铸造者生成不同，凭信可以由任何人创建，也可转移给任何人。需要在每一次转移中检查创建者（注：如果为非修改类转移，则保持不变）。

> **注：**<br>
> 初次创建凭信交易的创建者标识为空，因为此时尚无交易ID。<br>
> 创建者实际上可以通过回溯区块链找到，但这里明确为一条记录来提高效率（性能）。<br>


#### 描述

采用 `2+2` 字节定义配置。前两字节为基础配置，后两字节为扩展配置。之后为凭信描述，通常可阅读。

```go
// 基础配置（2字节）
 15] 含扩展配置。置位表示后面的2字节为扩展配置空间。
 14] 新建标记位。指示当前凭信交易是否为新建（含修改）。
 13] 是否可修改。指示描述和附件ID是否可修改，转移指令会检查输出项是否合规。
 12] 修改转换位。置位表示凭信由可修改转为不可修改。
 11] 销毁标记位。当前凭信转移能力终结（不再进入UTXO集）。
 10] （未用）
9-0] 指明描述文本长度，10位最长可表达1kb内容。

// 扩展配置（2字节，可选）
...] （未用）
 01] 有转移次数。置位表示后面跟随2字节转移次数递减剩余值字段。
 00] 包含有效期。置位表示后面跟随4字节有效期字段。以秒为单位，从交易时间戳开始计时。
```

> **注记：**<br>
> 转移次数和有效期可能同时存在，此时谁先结束谁有效。<br>
> 当转移次数剩余值递减为零或有效期抵达时，交易的构造者需要对销毁标记置位。<br>


#### 附件ID（可选）

如果**输出类型**字段中附件标记置位，表示该交易包含有一个长 `32+4` 字节的附件ID：前32字节为附件数据的哈希摘要，后4字节则为附件大小（字节数）。

要求提供附件大小信息，可为某些用途提供便利。这些附件会被存储到 `archives` 公共服务网络上。


#### 锁定脚本

限定该凭信转移的一段代码。如果用户提供的解锁脚本使得锁定脚本成功执行，则转移成功。

> **注记：**
> 如果描述字段的销毁标记置位，但此处依然有脚本代码，会被视为 **识别脚本**（同下证据信元逻辑）。


#### 附：凭信的转移验证逻辑

**可修改凭信：**

> 无输入源时：表示初始新建。新建标记位置位，可修改标记位置位。<br>
> 有输入源时：表示凭信转移。保持当前可修改时，按「修订传递」验证；转为不可修改时，可修改标记清位，修改转换标记置位。<br>

**不可修改凭信：**

> 无输入源时：表示初始新建。新建标记位置位，可修改标记位置零。<br>
> 有输入源时：表示凭信转移。检查输入源新建或修改转换标记位，置位则为「引用传递」（记录源交易ID），否则为「复制传递」（复制源交易记录的值）。<br>


> #### 凭信源身份记录
>
> 引用传递：输出中记录凭信源引用：理想块高度 + 交易ID + 输出下标。合计 `4+32+2` 字节。<br>
> 复制传递：输出中记录与输入源的记录保持一致（即记录的值不变）。<br>


> #### 修订传递逻辑
>
> 如果内容发生了变化（包括附件变化），都视为新建逻辑，新建标记位置位。<br>
> 如果内容未变，新建标记清位。凭信源记录根据输入源情况采用引用传递（新建时）或复制传递（非新建）。<br>。


##### 说明：

- 可修改凭信可以通过清位修改标记而转变为不可修改凭信，但反过来则不行。这是一个有意的限制。
- 由可修改转为不可修改后，修改转换标记置位。如果内容已修改，新建标记也需置位。
- 凭信源身份的引用/复制传递使得追溯创建者很容易，这有时很有用，比如追溯子链的创建者以实施某种验证（「侧链微支付」）。


### 证据

与币金和凭信不同，证据是用来表达存在的。存在证明仅可使用而不能转移。

借助于区块链的信用能力和网络本身，它的用途可能会有很多，简单的如 **存在性证明**（如版权声明）、**CA证书存储**（供公开检索）、**话题索引**（一条子链就是一个自由的讨论集），**基础凭证**（如选举子链的授权公钥清单），或者作为第三方应用所需的定制数据存储等。

证据可由任何参与交易的人创建。因为不可转移，所以创建者即是当前交易的主人。


#### 名称

证据的标题，类似币金和凭信中的接收者。最长256字节，首字节定义实际长度。


#### 内容

由前 `2+4` 字节定义配置。

```go
// 首2字节。
  15] 含有效期。置位表示后面跟随4字节有效期字段。
  14] 超长标记。置位后表示后续14位全部用于记录内容长度。
13-8] 自定义区。如果超长标记未设置，此处可自由定义。
 7-0] 内容的长度定义（字节数），可能与前6位合并使用，以最大支持到16KB内容。

// 4字节有效期，可选
 [32] 以秒为单位的有效期时长。
```

#### 附件ID

参考前面凭信部分说明，可选。


#### 识别脚本

用于证据的程序化识别和处理。因为证据不可转移，不作为新交易的输入项（验证），所以该脚本只对识别者有意义。



## 输出标记

交易的输出脚本有多种类型，各自含有不同的约束。此标记由1个字节设置。

```go
7] 自定义类。声明为第三方扩展，仅对相应的客户端有用。
6] 包含附件。声明是否携带附件。用于凭信和证据两种信元的交易。
5] 中介管理。声明为接收前阶脚本跳转的「管理者」脚本。
4] 定制验证。停用系统内置的默认验证，完全由锁定脚本实施控制。
3] 多重签名。标记接收者为多重签名地址，以便于启动内置的多重签名验证。
2] 证据交易。标记当前输出为证据，不能作为输入源。
1] 凭信交易。标记当前输出为凭信（新建或转移）。可以作为输入源。
0] 币金交易。标记当前输出为币金支付。可以作为输入源。
```


### 多重签名

标记当前接收者是否为多重签名地址，告知系统在采用内置验证时该采用哪一种签名验证逻辑。


#### 多重签名地址

多重签名账户的地址构造流程：

1. 每个公钥执行哈希运算得到各自的公钥地址：`PKH = Hash( pubKey )`。
2. 全部公钥地址有序串连，前置2字节的 `n/T` 配比后计算总的哈希：`MPKH = Hash( <n/T> + PKH_1 + PKH_2 + ... )`。
3. 在该总哈希前面前置2字节的 `n/T` 配置（明码公开，友好），即为多重签名的公钥地址。
4. 将上面的总公钥地址编码为文本形式，即为多重签名账户地址。

这里，每一位参与者只需要提供自己的公钥地址（而不是公钥本身），这提高了安全性。另一方面，它还让参与者变得更自由，比如使用既有的地址，或是匿名参与。

公钥地址集的顺序由构造者自己决定，并不一定按字节值排序。当用户在构造交易提供解锁脚本时，公钥和公钥地址需前置**1字节的序号**标识。

> **注：**<br>
> 多重配比的 `n/T` 表示 `T` 个公钥中至少有 `n` 个签名才有效。<br>
> `n` 和 `T` 每个值各占用 `1字节`，最多可表达 `255/255` 的多重验证逻辑。<br>


#### 多重签名的验证

提供的解锁实参：

- `n/T` 中 `n` 个公钥对交易的签名数据。
- `n/T` 中 `n` 个公钥。
- 未参与签名的公钥地址集（`T-n` 个）。**注**：用于与 `n` 个公钥共同构造多重签名地址。
- 每个公钥和公钥地址的**首字节**为其所在清单中的*序位*（`0-255`）。

> **注意：**
> 公钥或公钥地址在各自集合中没有顺序要求，但其首字节序位构成的最终集合需是一个从0开始的连续数列 `[0-T)`。
> 签名集内的成员数据需与公钥集内的成员按位置一一对应。

验证过程：

0. 提取目标账户地址中的 `n/T` 配比和公钥地址。
1. 检查 `n/T` 配比是否与提供的数据量相符：`n` 个公钥和 `T-n` 个公钥地址。
2. 对 `n` 个公钥计算哈希，与 `T-n` 个公钥地址合并。**注**：用首字节序位设置所属位置。
3. 前置 `n/T` 配比计算多重签名公钥地址。检查两个地址是否相同。
4. 验证 `n` 个公钥的签名数据。


#### 附：公钥地址的文本编码

将公钥地址采用某种编码方式编码为文本可读形式，即为账户地址。

**编码：**

0. 公钥地址添加识别前缀，即“前缀+公钥地址”**注**：加号（+）仅表示连接。
1. 对其执行两次哈希运算，取末尾4字节为**校验码**。
2. 在公钥地址之后附上校验码（*此时无前缀*），编码为文本地址。
3. 附上识别前缀，即“前缀:文本地址”即为可视的账户地址。**注**：分隔符（`:`）是系统自动添加的。

**校验：**

0. 提取识别前缀（借助 `:` 分隔符）和文本地址。
1. 将文本地址解码为字节序列。截取末尾4字节校验码，前段即为公钥地址。
2. 公钥地址前置识别前缀（即“前缀+公钥地址”），执行两次哈希运算取末尾4字节为校验码。
3. 比较上面两个校验码，相同则地址合法。


### 定制验证

默认情况下，花费者需要提供约定格式的解锁数据（签名相关部分），系统提取这些数据来完成对用户合法性的验证。

通常，默认验证是必要的，它可以省掉用户书写相同的锁定脚本，而把精力投入在另外的校验部分。但有时花费者也想要有更多或更灵活的控制，比如Bitcoin中存在的*支付到脚本（P2SH）*，这时就可以通过设置定制验证标记来取消系统内置的验证。

在**P2SH**中，花费者提供一个哈希屏障，由支付者设置在锁定脚本的开头。这样，当花费者提供必要的前段脚本后，就可以执行验证了。这样的脚本开头通常为：

> `SOURCE[-2] FN_HASH256 DATA{<ScriptHash>} EQUAL PASS`

其中：

- `SOURCE[-2]` 提取前段源脚本字节序列（可用 `SYS_NULL` 标记起点）。**注**：哈希屏障计算时需要在末端包含本指令（但不在解锁脚本内）。
- `FN_HASH256` 对提取的脚本字节序列计算哈希摘要。
- `DATA{<ScriptHash>}` 这就是花费者提供的哈希屏障，入栈。此时栈顶有两个哈希值。
- `EQUAL` 对比栈顶两个哈希值是否相等，Bool值入栈。
- `PASS` 读取栈顶值，若为真则验证通过。

另外，因为锁定脚本可以自由定义约束，所以无需签名验证也可能是有意义的。比如结合环境条件（`IN/OUT` 指令）构造出来的约束，只要有人愿意或能够满足条件，也可以完成特定的逻辑。


### 中介管理

对交易输入的验证允许交易间跳转：从一笔交易跳转到另一笔交易继续工作。

这是本系统中一个重要的机制设计。接收跳转的输出就是管理者脚本，需要设置此标记位。这是严格的，它只能接受其它脚本的跳转进入，而不能直接作为一笔交易里的输入源。

这样的设计可以允许外部管理的介入，比如监管机构先构建一笔管理者交易，用途是接收其它交易的进入以收集传递过来的财务信息，这样就可以实现商家主动申报税务的功能。**原理**：监管机构自己实施验证，脚本跳转后，根据脚本指令可以触发链外服务监控App，进而衔接到机构内部系统，完成相关工作。

> **注：**
> 出于性能和安全的考虑，一个脚本中连续跳转的行为有次数限定。


### 自定义类

脚本中包含了第三方扩展指令时，需要进行此标注。扩展指令是私有的，由扩展所属的专用客户端理解和执行。此类输出无法被标准客户端理解，因此不能作为标准交易的输入源。

如果一笔输出被标记为自定义类，则后续7位就是长度计数，指明后续跟随的是该扩展的标识ID（<128字节长），再后面就是该扩展的私有脚本。第三方扩展的客户端依赖此ID来识别自己的数据。



## 签名消息

### 签名消息的种类

签名消息的种类由1个字节定义，表达了花费者多种可能的条件要求。**注**：锁定脚本表达的是支付者对花费者的约束。

```go
7] （未用）
6] （未用）
5] `SIGIN_ALL`  包含全部输入项。可单独使用
4] `SIGIN_ONE`  仅包含当前输入项（自身）。可单独使用。
3] （未用）
2] （未用）
1] `SIGOUT_ALL` 包含全部输出项。。
0] `SIGOUT_ONE` 仅包含当前输入项相同偏移的输出项。。
```

其中低位的两项标记必须与高位合并使用，高位两个标记可单独使用。总计共**6**种组合：

- `SIGIN_ALL`: 仅签名全部输入，不含任何输出（类似 Bitcoin: `SIGHASH_NONE`）。含义：我同意使用我的资金参与这样一笔交易，至于钱怎么被分配，我不是特别在意。
- `SIGIN_ALL | SIGOUT_ALL` 签名全部输入和输出（类似 Bitcoin: `SIGHASH_ALL`）。含义：我只同意以这些输入和这些输出组合为一个交易，转移我的资金。
- `SIGIN_ALL | SIGOUT_ONE` 签名全部输入和当前输入对应的同偏移输出（类似 Bitcoin: `SIGHASH_SINGLE`）。含义：我同意参与使用所有这些输入的交易，只要这个地址收到一定数量的钱。
- `SIGIN_ONE`: 仅签名当前输入，不含任何输出（类似 Bitcoin: `SIGHASH_NONE|SIGHASH_ANYONECANPAY`）。含义：我愿意发送这笔资金，不问缘由（实际上任何人都可以花费）。
- `SIGIN_ONE | SIGOUT_ALL` 仅签名当前输入和全部输出（类似 Bitcoin: `SIGHASH_ALL|SIGHASH_ANYONECANPAY`）。含义：我同意参与这笔交易，只要这些受益人能收到这些款项，其他参与者随意。
- `SIGIN_ONE | SIGOUT_ONE` 仅签名当前输入和相同偏移输出（类似 Bitcoin: `SIGHASH_SINGLE|SIGHASH_ANYONECANPAY`）。含义：我就是想移动这些资金到这个地址中，有无其他人参与这笔交易无所谓。


### 签名消息的构造

在交易的数据构造中，输入采用 **4-4-2** 结构，即：区块高度（`4`）+ 交易序位（`4`）+ 输出偏移（`2`）。结构短小，因此 `SIGIN_ONE` 通常会使用原始条目作为消息，而 `SIGIN_ALL` 则使用哈希摘要。

交易的输出部分是较复杂的，包含输出（锁定）脚本、接收者、金额、附件ID等等，数据量较大，因此 `SIGOUT_ONE` 和 `SIGOUT_ALL` 都会使用哈希。



## 脚本指令集

从更宽泛的意义上看，脚本就是合约，而合约是自由的。

本设计中的脚本指令包含了完整的流程控制语法，如：`IF`、`ELSE`、`SWITCH`、`CASE`、`EACH`（有限循环），运算操作符如：`+`、`-`、`*`、`/`，数据类型如：`Bool`、`Int`、`Bytes`、`String`、`Float` 等，以及其它必要的栈脚本结构。


### 基本概念

#### 数据栈

脚本的执行就是脚本中指令序列的逐个运行，大多数指令都是对数据进行操作，并返回一个或多个值。提供和存储这些数据的地方就是脚本的数据栈。

数据栈是后进先出（LIFO）的逻辑，脚本指令通过实参提取的方式从栈内获取数据，需要多少个实参取决于指令的参数定义。通常，从栈内取实参是一种**取出**的逻辑（从栈中弹出），而指令执行后的返回值则会自动入栈。

准确地说，指令实际上是通过下面的「实参空间」来获取的从参数的。

> **注记：**
> 数据栈存放的是通用类型值（`any`），各个指令（或其适配壳）需要自行检查并转换。


#### 实参空间

单一的栈结构会有一种局限，即脚本指令需要从栈中取值，同时其返回的值又会压入栈顶。这会造成一种排挤效应，十分不便于指令序列的连续操作。因此这里加入了「实参空间」的环节。

实参空间是一个临时的储值区：如果指令需要实参，系统会先从实参空间里获取，如果空间内已经无值，则再从数据栈里取值。这样就为栈式脚本的连续指令序列提供了一个数据腾挪的空间，消除了单一栈结构的数据排挤问题。

逻辑上，实参空间是一种队列结构：可以持续地向该空间末端添加数据，数据被取出时保持原添加的顺序。实参空间也简称为实参区，将由取值指令（`@`, `${}` 等）来添加赋值。

从实参区取值有两种方案：

1. **一次性提取**。如果指令需要实参，实参空间中的值会一次性全部取出（因此这些值的数量应当和指令的实参需求数量相符）。这种方式较为简单，可以减轻脚本构造者的思虑负担。
2. **可多次提取**。如果指令需要实参，会从实参区提取所需数量的值（因此这些值的数量必须至少等于指令的实参数量需求）。剩余的值会用于下一个指令的实参提取。

第二种方案能够提供更多一些的灵活性，它让连续指令的并列使用更方便：多个指令都仅从实参区中获得实参，而其返回值则连续入栈。但这种方案需要脚本构造者记住实参区还遗留了多少值，这多少会增加大脑思虑上的负担，而得到的好处可能并不明显（仅有利于并列使用场景）。

第一种方案可以透明过度到第二种方案，因此本系统目前采用第一种方案。


> #### 附：实参数量
>
> - 无需求（`0`）。不会读取实参区，因此也不影响当前实参区内的数据。
> - 固定数量（`n`）。从实参区取值，如果实参区无值，则自动从数据栈提取 `n` 条数据。**注意**：是否从数据栈取值，只取决于实参区是否为空（而非数量不足）。
> - 不定数量（`-1`）。提取出实参区全部的值，如果实参区无值则视为零数量，不会再从数据栈取值。


#### 附属参数

与实参不同，有时指令本身也需要描述，以说明它的某些特性，如 `IF` 指令的代码块长度。这些描述性的值就是指令的附属参数，简称「附参」。

附参紧跟在指令之后，大多数情况下，它们只有 `1~2` 个字节。这是一种基础设计，它可以有很多用途，比如指定数据的范围、子语句块的长度、指令的纵深扩展等。

附参是指令的基本属性之一，重在描述指令的**静态**属性或不应当被改变的量。


#### 局部域存储

在栈式脚本中并不方便书写变量声明和赋值。借鉴普通的编程语言，我们在这里也加入了一个局部域的设计。这是一个有限的存储空间，随着一个语法块的开始而开启，结束而结束。

与普通编程语言不同，此局部域里的数据只能按顺序添加和按下标位置读取（不像变量一样赋值），所以下层语法块并不能读取其父语法块或其它语法块内的局部存储（即当前语法块私有）。

另外，系统有一个全局域空间，可以像普通变量一样定位赋值和读取（同样按下标定位，但可赋值）。


#### 多返回值

指令可以返回一个或多个值，如果返回的是多个值，系统会将之自动展开入栈（**注**：如果被捕获到实参空间或局部域，也同样会展开）。

与指令的实参数量一样，指令的返回值数量也是指令的一个基本属性。

- 无返回值（`0`）。系统不会有任何额外的行为。
- 单返回值（`1`）。直接入栈或被捕获进入实参空间（`@`）或当前局部域（`$`）。
- 特定数量（`n`）。会被系统自动展开压入相应的存储区。
- 不定数量（`-1`）。同上会被系统自动展开，但数量可为零。实现为返回一个切片，由系统主动将切片展开。


#### 缓存区和外部监听

本设计中有包含交互逻辑的指令（如 `INPUT`、`OUTPUT` 等），这样区块链就可以与外部世界相关联，比如导出数据，由外部正在监听的中间件处理，从而完成外部事务。

脚本与外部的交互通过两个各自独立的缓存区实现，一个导出，一个导入。

中间件的驱动是由外部监听实施的，逻辑上，这些监听是私有的：只有需要外部事物的节点才需要部署。数据的导出&转出是非阻塞的，不会影响脚本的正常执行。

由于中间件的中介衔接，外部系统实际上可以是任意的。


### 指令空间规划

每个指令都有一个值，脚本就是指令的**值的**序列。用数值而不是字符串来表达指令，可以节省空间并让指令的解析和执行更为高效。

指令空间就是指这个值的范围。

本系统中使用了 `1字节` 的长度来标记该空间，也即全部指令不超过 `256` 个。如果有更多指令的需求，则通过指令附参的方式来扩展（注：这种纵深扩展理论上是无限的）。

此1字节的指令空间定义的是栈脚本语法中需要的基础结构和基本函数，可称为第一层面指令。大部分的脚本逻辑仅需要这些指令即可完成。

从大的特性上，可以划分为如下几个块段：

1. **基础指令段**：包含全部的语法相关的基础指令，如流程控制、数学运算、栈操作、对外交互和模式匹配等。占位：`[0-169]`，共 **170** 位。
2. **函数指令段**：高频和常用的功能性函数，也包含2个自扩展指令。占位：`[170-209]`，共 **40** 位。
3. **模块指令段**：定义一些基本和标准模块，以及1个自扩展指令。占位：`[210-249]`，共 **40** 位。
4. **扩展指令段**：专用于指令的扩展引用，包括2个基础扩展指令和2个私有扩展指令。占位：`[250-255]`，共 **6** 位。


### 指令命名和书写约定

根据指令的特性（是什么），划分了如下5大类别，其命名规则如下：

1. 基础功能。指令名无前缀，视觉上简洁明快。如：`PASS` 真值通过。
2. 系统调用。指令名前缀 `SYS_`，如：`SYS_TIME{}` 系统环境取值指令。
3. 功能函数。指令名前缀 `FN_`，如：`FN_CHECKSIG` 签名验证。
4. 模块引用。指令名前缀 `MO_`，如：`MO_MATH{}` 数学模块，`MO_MATH{Abs}` 调用 `math.Abs()`。
5. 扩展定制。指令名前缀 `EX_`，如：`EX_INST` 通用扩展指令。

指令的书写/显示约定：

- `{}` 花括号包围指令的关联数据，比如值指令的实际值、if语句块的子指令序列等。
- `[]` 中括号标示指令附参的值，非必需时可省略。如：`DATA[20]{...}` 表示20字节长的字节序列，可简写为 `DATA{...}`。
- `()` 除了脚本中作为表达式和优先级指令外，也用于文档说明中表达指令附参的长度（字节数）。如 `DATA{}(1)`，指示 `DATA{}` 指令包含一个1字节长的附参。
- `<>` 尖括号表达命名数据，如：`<pubKey>` 指一个公钥，`<hashSource>` 指一个哈希源（用于哈希运算的数据），`DATA{<pubKey>}` 表达实际入栈的公钥（脚本源码表达中）。

该约定用于程序员书写的脚本，也用于向普通用户展示脚本的含义。**注**：链上的脚本只是值序列而非指令文本。


### 指令的类型

从指令的功能（干什么）上看，有如下类型划分：

1. **值指令**。脚本中的一个实际的值，会自动入栈。如：`FALSE`、`TRUE`、`DATA{}` 等。
2. **截取指令**。拦截跟随指令的返回值，将它们添加到实参空间或局部域。如：`@`、`$` 等。
3. **栈操作指令**。对数据栈中的条目执行简单的操作，如：压入（`PUSH`）、弹出（`POP`）、引用（`TOP`）等。
4. **集合指令**。对数组/切片类集合的一些基础操作，如：`MAP`、`FILTER`、`MERGE` 等。
5. **交互指令**。与一个缓存区交互，执行栈数据的导出（`OUTPUT`）与导入（`INPUT`）等。中间件可与该缓存区交互，从而实现区块链外的逻辑。
6. **结果指令**。整段脚本有一个确定的结果。如：`PASS` 通行验证，失败即判为非法，`GOTO` 会跳转到另一笔交易。
7. **流程指令**。实现执行流的控制，包含：`IF{}`、`ELSE{}`、`SWITCH{}`、`CASE{}`、`EACH{}`、`BREAK` 等。
8. **转换指令**。对实参值进行类型转换，包含如：`BOOL`、`FLOAT`、`STRING` 等。
9. **运算指令**。包含加、减、乘、除、模、位移等数值运算，以及小括号的优先级分组等。
10. **比较指令**。比较2个实参值，如：等于（`EQUAL`）、大于（`GT`）、范围之内（`WITHIN`）等。返回一个布尔值。
11. **逻辑指令**。实现逻辑与（`BOTH`）和逻辑或（`EITHER`）的功能，或同时检测多个值（`EVERY`、`SOME`）。
12. **模式指令**。判断脚本是否符合预期的逻辑（模型），指令包含：`MODEL{}`、`#`、`_`、`?`、`...`、`!{}` 等。
13. **环境指令**。提供交易环境相关的一些数据，如：`IN{}`、`OUT{}`、`VAR` 等。
14. **工具指令**。实现某些实用功能的指令，如：`EVAL`、`COPY`、`MATCH`、`RANGE` 等。
15. **系统指令**。和系统级有关的一些功能指令。如：`SYS_TIME`、`SYS_NULL` 等。
16. **函数指令**。一些常用的基础或标准功能函数。如：`FN_HASH256`、`FN_CHECKSIG`、`FN_BASE32` 等。
17. **模块指令**。包含一些专项功能的特定模块，其中有它自己的指令集。如：`MO_RE`、`MO_TIME`、`MO_MATH` 等。
18. **扩展指令**。用附参引入扩展的更多指令，仅有少数几个。如：`EX_FN`、`EX_INST` 等。


### 示例

#### 通用的币金输出验证

用户构造一笔交易，输入源引用资金来源交易，提供解锁脚本。

如果解锁脚本与资金来源交易的锁定脚本串接后执行成功，则花费该笔输出成功（即用解锁脚本证明自己拥有所有权）。当前交易的输出（锁定脚本）即为这笔花费的去向，将由下一位用户解锁使用。

```go
// 解锁脚本：
// 由使用者在花费币金时提供。
DATA{<sig>}     // 签名
DATA{<pubKey>}  // 公钥

// 锁定脚本：
// 即源交易的输出脚本，已固化在区块中。
TOP FN_PUBHASH DATA{46af3fb481837fadbb421727f9959c2d32a36829} EQUAL PASS FN_CHECKSIG PASS
```

**解释：**

1. `DATA{<sig>}`：签名入栈。    **栈状态**：`[<sig>]`
2. `DATA{<pubKey>}`：公钥入栈。 **栈状态**：`[<sig> <pubKey>]`
3. `TOP`：引用栈顶项（不弹出），结果值自动入栈。注：相当于 `DUP[1]`。        **栈状态**：`[<sig> <pubKey> <pubKey>]`
4. `FN_PUBHASH`：取出栈顶1项计算公钥地址后入栈。即：`FN_PUBHASH(<pubKey>)`。**栈状态**：`[<sig> <pubKey> <pubHash>]`
5. `DATA{46af3fb481837fadbb421727f9959c2d32a36829}`：公钥地址序列直接入栈。注：非公钥本身，实为一层哈希屏障保护。**栈状态**：`[<sig> <pubKey> <pubHash> <data{...}>]`
6. `EQUAL`：取出栈顶2项作相等比较，结果 TRUE 或 FALSE 入栈。   **栈状态**：`[<sig> <pubKey> <true|false>]`
7. `PASS`：取出栈顶值检查是否为 TRUE，是则通过，否则失败。      **栈状态**：`[<sig> <pubKey>]`
8. `FN_CHECKSIG`：取出栈顶2项（即最初的 `<sig>` 和 `<pubKey>`），验证签名数据。结果 TRUE 或 FALSE 入栈。**栈状态**：`[<true|false>]`
9. `PASS`：取出栈顶1项检查是否为 TRUE，是则通过，否则失败。**栈状态**：`[]`

> **注：**
> 指令详情请参考后续「脚本基础指令集」部分。

**更多的例子请参考：**

- [链间兑换](examples/链间兑换.md)
- [存在性证明](examples/存在性证明.md)
- [链间授信](examples/链间授信.md)
- [批量付款确认](examples/批量付款确认.md)
- [网购支付流程](examples/网购支付流程.md)
- [实时税务](examples/实时税务.md)
- [版权登记](examples/版权登记.md)
- [侧链微支付](examples/侧链微支付.md)
- [选举子链](examples/选举子链.md)



## 主要特点

### 逻辑完整的执行流指令

在Bitcoin系统的脚本操作指令中，出于性能和安全的考虑，并没有循环类指令如 `OP_LOOP`，这有些缺憾。

通常，这样无约束的循环可能导致死锁攻击，但如果循环本身是天然有限的，则可以很好地缓解这一问题。本设计中的 `EACH{}` 指令即是这一有限循环，循环针对已有数据迭代，因此安全得多。

脚本的流程控制指令包括：

- `IF{}(1)`      实参为真时执行。附参明确了语句块的长度（因此也就无需**endif**了）。
- `ELSE{}(1)`    if 的可选分支。附参含义同上。
- `SWITCH{}(2)`  多分支选择指令。实参为后续条件分支的对比目标，2字节的附参明确了语句块的大小。
- `CASE{}(1,1)`  条件判断分支。两个附参分别指定了条件表达式和分支语句子块的长度，表达式的结果与 switch 的目标值比较，相等则执行子语句块。
- `DEFAULT{}(1)` 多选默认分支。所有 case 都不匹配时执行，通常放在最后，附参明确了子块长度。
- `EACH{}(1)`    数据集迭代。附参明确了语句块长度。
- `BREAK`        退出 each 迭代或 switch 语法块。
- `CONTINUE`     直接进入下一循环（each）。
- `FALLTHROUGH`  case 分支穿越。

> **附注：**<br>
> 如果一笔交易的验证需要消耗大量的资源，它可能不受欢迎而被加入黑名单，这对交易者构造交易是一种压力，或许可以促使他们构造尽量简单的交易。<br>
> 大多数语句块长度附参仅为1字节，因此子语句块长度不超过 `255字节`，这种限制可促使用户尽量扁平化代码逻辑，有利于审计。<br>


### 可与链外的数据交互

交互类指令 `INPUT` 和 `OUTPUT` 可用于从缓存区导入或向缓存区导出数据，`BUFDUMP` 实现缓存区数据的清空和对外递送（转出），触发外部预先注册的处理器，这样就实现了区块链交易驱动外部事务的逻辑。

交互行为在脚本执行时发生，它们是私有的逻辑，仅在需要事务处理的环境里存在，对于其它普通节点，导出&转出指令会无阻塞地执行，如果没有数据可导入，脚本即会终止。

因为是私有的逻辑，所以如果必要，客户端或许可以在任何时候执行脚本。


### 脚本执行环境限定

区块链是一个开放的系统，恶意的攻击者可能构建十分消耗资源的交易来拖累系统，因此这里有一些限制：

- 数据栈高度：`<= 256`。栈式脚本在运行过程中，数据栈内的数据大多会被即时使用，所以高度容量并不需要太大。
- 栈数据项大小：`<= 1KB`。
- 锁定脚本长度：`<= 1KB`。
- 解锁脚本长度：`<= 4KB`。
- 单笔交易大小：`<= 32KB`，不含签名数据。
- 每区块包含交易数量：`<= 64k`，2字节值范围。**注**：按6分钟一个区块计，平均 `182笔/秒`。
- 每区块大小：`<= 32MB`。
- JUMP嵌入次数：`< 10次`（运行时，下同）。
- GOTO跳转次数：`< 4次`。参考：管理者+审计者+第三方。

另外，系统内部的一些空间有如下特点：

- 局部域大小：`< 128`。支持负数从末尾引用。
- 实参空间：没有限制，但间接受制于数据栈或缓存区大小限制。
- 导入缓存区大小不作限制（客户机自负责）。

脚本的指令序列是顺序执行的且不可回退（没有返回到前端位置的指令），因此一个固定长度的脚本执行所消耗的资源是有限的。

> #### 附：对区块大小限额的思考
>
> 影响区块大小的因素有二：1. 打包交易的数量；2. 每笔交易本身的大小。<br>
> 本区块链交易不仅是币金交易，还包含凭信和证据的类型。相较于区块中交易的数量，交易本身的数据尺寸变化更大。<br>
> 因此设计倾向于硬性限制交易的数量，而通过对交易本身大小的限制来调节区块的大小。<br>
>
> 区块链可能更应该是一种介质而非平台，现实当中应该有很多相互协作的区块链存在，所以包含巨量交易的重要性可能并没有想的那么重要。<br>
> 设计预估的每区块交易数量是64k上限，这可能是合理的。<br>


### 第三方扩展

区块链主要是创建和传递信用，功能相对稳定，发展缓慢或许是一种正常的状态。

公共的区块链是一个公共的信用数据区，它为任意的第三方提供了一种现实的“依靠”。如果第三方应用借助于主链的网络、数据、状态、交互等实现自身的业务，这本身就是一种扩展了。

第三方扩展是私有的，主链客户端不理解也无法直接支持它们，这些业务是任意的。



-------------------------------------------------------------------------------

上一篇：[激励机制](4.激励机制.md)<br>
下一篇：[脚本基础指令集](6.脚本基础指令集.md)<br>
