//////////////////////////////////////////////////////////////////////////////
Copyright (c) 2019 - 2021 @cxio/blockchain

    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.3
    or any later version published by the Free Software Foundation;
    with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
    A copy of the license is included in the section entitled "GNU
    Free Documentation License".
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

## 基础指令集

> **注**：下面的代码并非Go语言代码，仅便于显示友好。


### 1. 值指令

在脚本中作为一个实际的值存在，直接自动入栈。

对于前面3个值指令（**0-2**），指令本身即代表了具体的值。对于前段的数值类值指令（**3-14**），附参即为数据本身，小括号内的数字指示了指令数据的长度（字节数）。

指令值区间：`[0-23]`，24个。

```go
指令值  指令名      说明
-----------------------------------------------------------
0       NIL         空值
        // 即Go语言中的 nil 值。

1       TRUE        真值（true）
2       FALSE       假值（false）
        // 类型：Bool，布尔值。
        // 在源码中书写指令名，解析为指令值，解码为所代表的值。
        // 例：
        // TRUE 解析为脚本指令值1，运行时解码为true。


// 以下指令的附参即为值数据。

3       {}(1)       int8，1字节：[-128, 127]
4       {}(1)       byte/uint8，1字节：[0, 255]
5       {}(2)       int16，2字节：[-0x8000, 0x7fff]
6       {}(2)       uint16，2字节：[0, 0xffff]
7       {}(4)       int32/rune，4字节：[-0x80000000, 0x7fffffff]
8       {}(4)       uint32，4字节：[0, 0xffffffff]
9       {}(8)       int64，8字节整数：[-1<<63, 1<<63 - 1]
10      {}(8)       uint64，8字节整数：[0, 1<<64 - 1]
        // 类型：Int，整数。
        // 附参：指令的关联数据。
        // 从源码解析为指令时，数据值的大小自动决定使用哪个指令。
        // 例：
        // {12756}  入栈正整数，指令选用int16（指令值5）。
        //          脚本中指令序列：首字节值5，后2字节为值 12756
        // {0xfff0} 入栈正整数，指令选用uint16（指令值6）。
        //          脚本中指令序列：首字节值6，后2字节为值 0xfff0（65520）
        // {'\n'}   支持单字符表达，根据码值解析为byte或rune。
        //          脚本中指令序列：首字节值4，后1字节值 10（换行符ASCII码值）。
        // 友好：
        // 支持一些常见命名字符，如：{NL} 一个换行符。
        // 支持千分位的书写，如：{12,345} 实为整数 12345。

11      {}(4)       浮点数（4字节，float32）
12      {}(8)       浮点数（8字节，float64）
        // 类型：Float，浮点数。
        // 附参：指令的关联数据。
        // 源码书写时必须包含小数点，支持科学记数法。
        // 解析为指令时，值的大小自动决定使用哪个指令。
        // 例：
        // {3.14159} 入栈浮点数 3.14159。指令值为11。
        // {2.1606e108} 超出float32容量。指令值为12。
        // 注记：
        // 系统实现可能会统一转换到float64类型后使用。

13      TIME{}(~)   时间表达式
        // 类型：Date。
        // 附参：UNIX时间戳。变长正整数。
        // 花括号内书写为标准格式的时间表达式（RFC3339）。
        // 例：
        // TIME{2006-01-02}
        // TIME{2020-11-24T15:04:05+08:00}
        // 注：
        // 解析的UNIX时间戳精确到毫秒。

14      （保留未用）


// 以下指令的附参标明数据的长度（字节数）。

15      {}(1)+N     大整数，字节长度不定（<256）
        // 类型：BigInt。
        // 附参：实际数据占用的字节数。
        // 注：也即Go语言中 math/big 包里的Int类型。
        // 例：
        // {0x8000ffff 8000ffff 8001}
        // 超出了uint64的表示范围，会被解析为大整数。
        // 注记：
        // 大数值通常用16进制书写，允许值内空格友好。

16      DATA{}(1)   字节序列数据。1字节附参
17      DATA{}(2)   字节序列数据。2字节附参
        // 类型：Bytes，字节序列。
        // 附参：实际数据的长度（字节数）。
        // 源码书写时使用16进制字符串，解析时值的长度自动决定指令值（若未指定附参）。
        // DATA{}(2) 指令2字节附参最大可表示64kb数据。
        // 例1：
        // DATA{46af3fb481837fadbb421727f9959c2d} 入栈16字节值，按16进制解析。
        // 解析后的指令序列：
        // [16|16|0x46|0xaf|0x3f|...]
        // 其中：指令值（16）1字节，附参值（16）1字节，后续16字节数据。
        // 例2:
        // DATA[8]{46af3fb4} 入栈8字节，后续不足者用0值填充。
        // 解析后的指令序列：
        // [16|8|0x46|0xaf|0x3f|0xb4|0|0|0|0] 指令值+附参值+数据共10字节。
        // 注：
        // 花括号内的16进制字符串无需前置 0x 标识。

18      TEXT{}(1)   文本数据。1字节附参
19      TEXT{}(2)   文本数据。2字节附参
        // 类型：String，字符串。
        // 附参：实际字符串 `UTF-8` 编码字节数。
        // 从源码解析为指令序列时，文本的字节长度自动决定使用哪个指令。
        // 例：
        // TEXT{Hello}      入栈 Hello 文本串。
        // TEXT{ Hello }    同上，首尾空格视为显示友好（非数据），可选。
        // TEXT{"Hello "}   若需在首尾包含空白，需要使用双引号包围。
        // 注意：
        // 不必也不应当手工指定附参值大小。

20      /.../flag(1)    正则表达式
        // 类型：RegExp。
        // 附参：表达式占用字节数。
        // 双斜线之内即为表达式的内容（类似JavaScript语法）。
        // 例：
        // /[a-z0-9]+/i   ASCII字母和数字，忽略大小写
        // 注记：
        // 运行时会被解析为一个正则表达式对象。

21-22   （保留未用）

23      CODE{}(1)   代码/指令序列
        // 类型：Script。
        // 关联数据为一段解析后的指令序列（指令值+附参+数据）。
        // 附参：序列长度。
        // 例：
        // CODE{
        //      TOP FN_HASH256 DATA{<hashResult>} EQUAL PASS
        // }
        // 入栈一段哈希屏障验证的指令序列。
        // 注：
        // 附参无需书写，将由解析器解析后自动设置。换行是一种友好。
```


### 2. 取值指令

截取后面跟随指令的返回值，让它们不再自动入栈。依指令的不同，截取的值可能放入实参空间（`@`），或者添加到当前的局部域中（`$`）。另外还有一个从局部域中取值的指令（`$(1)`），附参定义了取值位置。

最后还有一个特殊指令：实参直取（`~`），表示后面紧跟的指令直接从数据栈取实参（跳过实参区）。它对 `@` 和 `$` 指令无效，如果它跟在这两个指令之后，会被简单跳过。

这是几个用特殊符号表示的指令，功能独特。作为一种显示方便，符号与后面跟随的指令无需空格分隔。

指令值区间：`[24-27]`，4个。

```go
指令值  指令字      说明
-----------------------------------------------------------
24      @           实参捕获
        // 拦截后一个指令的返回值添加到实参区。
        // 因为实参空间是一个值队列，所以也可以形象地理解为放入当前位置。
        // 例1：
        //      {0} @PEEKS[2] @SPREAD PRINT[16]
        // 获取栈底2个值的切片放入实参区，展开该切片，向控制台打印它们。
        // 例2：
        //      @POPS[3] OUTPUT BUFDUMP
        // 弹出栈顶3项数据为一个切片，输出到缓存区并转储清空。
        // 注：
        // 如果@后面是实参直取指令~（见下），会简单跳过。

25      ~           实参直取
        // 指示后一个指令的实参将从数据栈直接提取（跳过实参空间）。
        // 这是一种主动的取值渠道切换。
        // 该指令通常与后面的指令紧邻，但空格是可选的。
        // 例：
        // ~EQUAL   直接取栈顶两个值比较相等与否，返回一个布尔值入栈。
        // @~EQUAL  同上取栈顶两个值比较，但结果被截取放入实参区。
        // $~EQUAL  同上比较，结果添加到当前局部域。
        // 注记：
        // 支持跳过实参空间取实参，可为数据的腾挪增加更多灵活性。

26      $           局域存值
        // 截取后一个指令的返回值添加到当前局部域中。
        // 局部域是一个静态堆叠空间（只添加），高度小于128（最多可添加128个值）。
        // 通过位置下标引用堆叠中成员。
        // 与实参创建指令@相同，如果后面是实参直取指令~，会简单忽略。
        // 例：
        // $TOP       引用栈顶项添加到当前局部域中（实为复制）。
        // $POPS[3]   弹出栈顶3项添加到局部域中（3个成员的切片）。
        // ${100}     将值 100 直接存入局部域。
        // @POPS[3] $SPREAD  弹出栈顶3项打包为一个切片，展开添加到局部域中。

27      $(1)        局域引用
        // 按添加时的顺序引用局部域的值。
        // 这可视为上面$的逆指令。
        // 作为取值指令，它引用的值会自动添加进实参区而非入栈。
        // 附参：局部域成员下标，支持负数从末尾算起。
        // 例：
        // $[0]   引用第1个添加进局部域中的值。
        // $[-1]  引用最后一个添加到局部的值。
        // 提示：
        // 作为友好，可以用$存值时所截取指令的名称来取值，名称用花括号包围。
        // 不过需要注意名称重复覆盖的问题，最好就近使用。
        // 例：
        // $POP   弹出栈顶项添加到当前局部域。
        // ${POP} 从局部域获取上面添加的值。
        // $MO_MATH.Abs   取栈顶值计算绝对值后，添加到当前局部域。
        // ${MO_MATH.Abs} 从局部域中获取上面添加的值。
        // 注：
        // 模块方法调用表示为用句点连接模块名和方法名。
        // 例：
        // $[0] $[1] $[2] PUSH
        // 将局部域前3个值压入到数据栈。
```


### 3. 栈操作指令

对脚本数据栈中的条目执行直接的操作，如：入栈、出栈、引用、转移等。通常会配合取值指令 `@` 或 `$` 使用。

指令值区间：`[28-37]`，10个。

```go
指令值  指令字      说明
-----------------------------------------------------------
28      NOP         无操作
        // 实参：不定数量。
        // 无任何操作，但会读取实参区，即清空。
        // 返回值：无。
        // 例：
        // @INPUT[] NOP 读取导入缓存区到实参区，然后清空。
        // @SHIFT[] NOP 同上原理，清空数据栈。
        // NOP          无任何行为，继续。
        // 注记：
        // 不定数量实参允许0个实参（系统不会自动从数据栈取值）。

29      PUSH        数据入栈
        // 把实参区全部内容按顺序压入数据栈。
        // 实参：不定数量。
        // 返回值：无。
        // 例：
        // @PEEK[0] @INPUT[] PUSH  提取栈底项和缓冲区全部数据，顺序压入数据栈。
        // ... PUSH  如果实参区为空，这是一个空操作。

30      SHIFT(1)    转移栈顶条目
        // 移出栈顶多个条目，保持原顺序展开到目标位置。
        // 附参：取栈条目数。uint8类型，0值表示全部。
        // 如果条目数超出栈高度，执行会失败。
        // 返回值：多值自动展开。
        // 例：
        // @SHIFT[4]    移出栈顶4项原样添加到实参区。
        // $SHIFT[4]    同上但添加到当前局部域。
        // @SHIFT[]     移出数据栈全部条目到实参区。0可选。
        // @SHIFT[0]    同上。
        // SHIFT[4]     移出4项又原样返回入栈，没有意义。
        // @SHIFT[1]    移出栈顶1项到实参区，与 @POP 同。
        // 注意：
        // 转移会维持栈内数据的先后顺序，即先入栈的在前。
        // 通常前置取值指令，否则返回值会重新入栈（没有意义）。
        // 注：
        // 某种程度上可视为 PUSH 指令的逆操作。

31      CLONE(1)    克隆栈顶条目
        // 克隆栈顶多项数据，保持原始顺序展开到目标位置。
        // 附参：克隆数量。uint8类型，0值无意义。
        // 返回值：多值自动展开。
        // 例：
        // @CLONE[3]    克隆栈顶3项，展开添加到实参区。
        // $CLONE[3]    同上克隆展开添加到当前局部域。
        // CLONE[3]     克隆栈顶3项展开入栈。
        // CLONE[0]     无克隆项，没有意义。
        // 提示：
        // 与后面运算指令DUP的区别：
        // - DUP[n]     取出栈顶 1 项复制 n 次，返回 1+n 项展开。
        // - CLONE[n]   复制栈顶 n 项 1 次，返回 n 项展开。
        // 例：
        // DUP[1]       取出并复制1次，返回两项展开。栈顶有两个相同数据
        // CLONE[1]     引用复制1项，返回一项入栈。效果同上。
        // TOP          引用栈顶项返回，效果同上。


// 以下指令直接读取数据栈，无实参。
// 注：返回的切片不会自动展开。

32      POP         栈顶项弹出
        // 返回值：栈顶项。
        // 如果没有前置取值指令，返回值会自动重新入栈（无意义）。
        // 例：
        // @POP     弹出栈顶项添加到实参区。
        // $POP     弹出栈顶项添加到当前局部域存储。
        // POP      弹出栈顶项又返回入栈，没有意义。

33      POPS(1)     栈顶多项弹出
        // 附参：弹出的条目数。
        // 附参为uint8类型，0值表示弹出全部。
        // 如果条目数超出栈高度，执行会失败。
        // 返回值：一个切片
        // 弹出的集合维持栈内数据原有的顺序（先进者在前）。
        // 例：
        // POPS[4]  打包栈顶4项为一个切片。
        // @POPS[4] 弹出栈顶4项打包为一个切片添加到实参区。
        // @POPS[]  同上打包添加但取出栈内全部条目。@POPS[0] 同。

34      TOP         引用栈顶项
        // 返回值：栈顶项。
        // 如果没有前置取值指令，返回值会自动重新入栈。
        // 例：
        // @TOP 引用栈顶项添加到实参区。
        // TOP  引用栈顶项并返回入栈，相当于克隆/复制1项。

35      TOPS(1)     引用栈顶多个条目
        // 附参：引用条目数。
        // 附参uint8类型，0值无引用（与POPS不同）。
        // 如果条目数超出栈高度，执行会失败。
        // 返回值：一个切片。
        // 同POPS，成员维持栈内原有底顶顺序。
        // 例：
        // TOPS[1] 引用栈顶项封装为一个单成员切片返回。
        // TOPS[3] 引用栈顶3项封装为一个切片返回。
        // TOPS[]  无引用返回一个空切片。


// 以下指令由实参指定下标位置。

36      PEEK        引用栈内任意位置条目
        // 实参：目标条目下标。
        // 栈底位置为0，支持负数从栈顶算起。
        // 返回值：引用目标项。
        // 例：
        // {-1} PEEK    与 TOP 效果相同。
        // {0} PEEK     引用栈底项入栈（克隆栈底项到栈顶）。
        // {0} @PEEK[]  同上引用，添加到实参区。
        // {0} $PEEK[]  同上引用，放入当前局部域。

37      PEEKS(1)    引用栈内任意位置段条目
        // 附参：引用条目数。
        // uint8类型，最多引用255条。0值表示目标位置之后全部。
        // 实参：起始位置下标。
        // 栈底位置为0，支持负值从栈顶算起（当前实参不计在内）。
        // 如果位置下标超出栈高度，或实际数量不足，执行会失败。
        // 返回值：目标位置段条目的切片。
        // 例：
        // {0} @PEEKS[5]    引用栈底5项数据封装放入实参区。
        // {-5} @PEEKS[0]   引用栈顶5项封装放入实参区，同：@TOPS[5]
        // {0} PEEKS[5]     引用栈底5项封装返回入栈。
```


### 4. 集合类指令

支持可迭代集合（通常是一个切片/数组）的一些基本操作。

指令值区间：`[38-45]`，8个。

```go
指令值  指令字      说明
-----------------------------------------------------------
38      SLICE(1)    局部切片
        // 对切片切分出一个子切片。
        // 附参：新切片的大小。uint8类型，0值表示目标位置之后全部。
        // 实参1：目标集合。
        // 实参2：起始下标，支持负数从末尾算起。
        // 返回值：一个切片。
        // 例：
        //      @POP @{5} SILCE[3]
        // 取栈顶项（集合）内第6个之后3个成员（[5,6,7]）。
        // 注意：
        // 如果目标位置之后成员不足，执行失败。
        // 如果起始下标超出集合大小，执行失败。
        // 如果起始下标等于目标集大小且附参为0，返回一个空切片。

39      REVERSE     序列反转
        // 将切片内的成员顺序反转。
        // 实参：目标集合。
        // 返回值：一个切片。

40      MERGE       分片合并
        // 将多个切片合并为一个切片（子成员合并）。
        // 实参：不定数量。
        // 返回值：一个切片。
        // 例：
        // @SHIFT[3] MERGE  栈顶3项（都为切片）添加到实参区，合并为一。

41      SPREAD      序列展开
        // 将目标切片展开返回。
        // 如果前置取值指令，会展开添加到目标空间。
        // 实参：一个切片。
        // 返回值：不定数量。
        // 例：
        // $SPREAD  取栈顶项展开压入当前局部域。
        // @SPREAD  取栈顶项展开添加到实参区。
        // ~SPREAD  将栈顶项展开后返回入栈（POPS逆操作）。
        // 注意：
        // 栈顶项需要是可展开类型，比如一个切片条目。
        // 提示：
        // 连续的 @~SPREAD 可将栈内多个切片逐一展开到实参区。

42      GLUE        成员合并
        // 将切片的成员串连在一起。
        // 各个成员之间紧邻，并没有分隔彼此的分隔符。
        // 实参：一个切片。
        // 返回值：一个字节序列。
        // 例：
        // POPS[3] GLUE 将栈顶3项数据打包后串连在一起。

43      （保留未用）


// 下两个指令含子语法块：
// 包含一个私有数据栈，实参用于初始化该数据栈。

44      MAP{}(1)    映射操作
        // 针对目标集，迭代每一个成员执行子语句块，返回值构造为一个最终切片。
        // 附参：子语句块长度。
        // 实参：不定数量。
        // 返回值：一个切片。
        // 语法：
        // 子语句块拥有一个局部私有环境（数据栈、实参区），与上层脚本无关。
        // 私有环境在各个迭代之间是共享的。
        // 局部变量：
        // - ${Value}   // 当前条目数据
        // - ${Index}   // 当前循环下标，从0开始
        // - ${Array}   // 迭代集本身
        // - ${Total}   // 迭代条目总数
        // 例：
        // {10} RANGE[3]    // 创建了一个切片 [10,11,12] 入栈
        // {200} {300}      // 简单入栈2个值
        // @SHIFT[2]        // 转移为实参（将进入MAP的私有栈）
        // MAP{
        //      ${Index} @POP PRINT
        //      ${Index} ${Value} PRINT
        //      @( ${Value} * 2 ) RETURN
        // }
        // 将打印共3组值：
        // - 0 300      // 第1次
        // - 0 10
        // - 1 200      // 第2次
        // - 1 11
        // - 2 <nil>    // 第3次，栈内已无值
        // - 2 12
        // 返回的结果集：[20, 22, 24] 自动进入上层数据栈。

45      FILTER{}(1)   成员过滤
        // 针对目标集，迭代每一个成员执行子语句块，提取返回真值的源成员。
        // 附参：子语句块长度。
        // 实参：不定数量。
        // 返回值：一个切片。
        // 语法和局部变量参考上面MAP指令。
        // 例：
        // {10} RANGE[4]        // 创建了一个切片 [10,11,12,13] 入栈
        // FILTER{              // 私有栈为空
        //      ( ${Index} % 2 )
        //      @BOOL RETURN
        // }
        // 返回的结果：奇数集 [11, 13]，进入上层数据栈（整体返回值）。
        // 注：
        // 依然可以前置取值指令截取返回值：@FILTER{...}
```

> #### 关于Each
> `EACH{}` 指令是作为流程控制而非集合指令对待，一是因为它无需返回值，二是它内部应支持 `BREAK` 指令。<br>
> 另外，因为只是流程控制指令，所以 `EACH{}` 也没有子语句块的私有栈逻辑。<br>


### 5. 交互指令

在脚本的执行中存在一个数据的「缓存区」结构，它是与外部世界发生联系的一个中介区域。

缓存区是一个先进先出（FIFO）的队列结构，读取即为移出。导入和导出是两个各自独立的区域。对缓存区的读取和写入是非阻塞的，不影响脚本的连续执行。

指令值区间：`[46-51]`，6个。

```go
指令值  指令字      说明
-----------------------------------------------------------
46      INPUT(1)    导入缓存区数据
        // 附参：读取的条目数，0值表示全部。
        // 注意如果读取的数量不足，执行会失败（严格）。
        // 实参：无。
        // 返回值：不定数量自动展开到目标空间。
        // 例：
        // @INPUT[0]    导入缓存区全部数据展开到实参区。
        // $INPUT[3]    导入缓存区头部3项数据展开添加到当前局部域。
        // INPUT[3]     导入缓存取头部3项数据展开入栈。
        // @INPUT[] NOP 导入缓存区全部数据到实参区，然后清空。

47      OUTPUT      导出数据到缓存区
        // 实参：不定数量。
        // 因为实参为不定数量，所以仅会导出实参区内容。
        // 与INPUT和SHIFT指令类似，有自动展开能力。
        // 例：
        // @SHIFT[] OUTPUT  移出数据栈全部内容到缓存区（原样保持）。
        // ... OUTPUT  若实参区为空，无任何效果。

48      BUFDUMP     导出缓存区数据转储
        // 将导出缓存区内容转储到外部（清空缓存区）。
        // 实参：无。
        // 第三方服务可预先注册处理器，接收转储的数据并完成自己的逻辑。
        // 这也是一个无阻塞操作，但可触发外部响应机制。
        // 注：
        // 有无第三方是一种私有逻辑，只有需要的节点才需要执行。
        // 转储时可能包含一些当前脚本执行的状态。

49-50   （保留未用）

51      PRINT(1)    控制台打印
        // 将实参区的内容打印到标准控制台。
        // 附参：打印的格式标记。
        //      0   智能格式，默认
        //      2   二进制
        //      8   八进制
        //      10  十进制
        //      16  十六进制
        //      ... 其它标记
        // 实参：不定数量。
        // 友好：多个实参条目间以一个空格分隔。
        // 例：
        // @TOP PRINT[0]  用智能格式打印栈顶项数据。
        // TOPS[3] @SPREAD PRINT[16]  打印栈顶3项数据的十六进制表示。
```


### 6. 结果指令

对脚本的执行实施检查和控制（通关），如：通过、失败、退出或跳转等。如果脚本执行中未碰上失败，就视为验证通过。

通常来说，锁定脚本中必然存在通关性指令 `PASS` 或 `FAIL`，不然就没有锁定的逻辑（任何人皆可“解锁”脚本）。

指令值区间：`[52-59]`，8个。

```go
指令值  指令字      说明
----------------------------------------------------------
52      PASS        检查通过（安检）
        // 实参值为true时通过，否则失败。
        // 失败会导致脚本结束，信用转移失败（即验证失败）。
        // 实参：布尔值。
        // 注记：
        // 通关失败可能触发某种通知机制，以便外部可以了解情况。
        // 如果外部需要监控验证，这是很有必要的。

53      FAIL        验证失败
        // 实参值为true时失败。
        // 这是 NOT PASS 的简捷版，但表意更清晰。
        // 实参：布尔值。

54      GOTO(4,32,2)  执行流跳转（独立）
        // 跳转到目标区块的某个交易输出脚本。
        // - 实参区数据传递到新脚本作为数据栈内容。
        // - 新脚本延续当前的校验，但有其自身的环境（数据栈、全局空间、缓存区）。
        // - 新脚本的验证结果即为当前脚本的结果。
        // 附参1：区块高度（理想块），uint32类型
        // 附参2：交易ID，32字节哈希序列
        // 附参3：输出项索引，uint16类型。
        // 实参：不定数量。
        // 例：
        //      @SHIFT[10] GOTO[1000, 0xcca750..., 1]
        // 提取栈顶10项数据，跳转到第1000号理想块的目标交易的第2项输出，传递实参为其数据栈初始内容。
        // 注：
        // 实参也可以是一个 CODE{} 的指令值序列。
        //
        // 安全性：
        // 考虑安全性和性能，系统的实现中对连续跳转会有一些限制。

55      JUMP(4,32,2)  执行流跳转（嵌入）
        // 跳转定位与 GOTO 指令相同。
        // 目标脚本为嵌入逻辑，共享当前的脚本环境（数据栈、全局空间、缓存区）。
        // 子脚本有自己的顶层局部域。
        // 附参：（同前）
        // 实参：无。
        // 例：
        //      JUMP[1000, 0xcca750..., 1] FN_HASH256 DATA{...} EQUAL PASS
        // 跳转执行嵌入代码。
        // 返回后取栈顶值计算哈希摘要（FN_HASH256）和后面的工作。
        // 注：
        // 目标子脚本可能已往当前栈中添加了哈希源数据。
        //
        // 安全性：
        // 与 GOTO 类似，脚本中允许使用的JUMP指令有一个限度。

56-57   （系统保留）

58      EXIT        脚本结束
        // 结束脚本的执行。至此无错视为验证通过。
        // 如果实参区有值，返回该值（到系统，可能会被处理）。
        // 实参：不定数量。
        // 返回值：
        // 即实参值，任意类型。多个值会被转为一个切片。

59      RETURN      返回一个值
        // 从子语句块退出并返回一个值。
        // 只适用于函数式语句块 MAP{} 和 FILTER{}，退出当前迭代。
        // 实参：任意类型。
        // 返回值：即实参值。
        // 例：
        //      MAP{
        //           ... @POP RETURN
        //      }
        //      @SPREAD
        // 子语句块每次迭代返回内部栈顶值。
        // 全部迭代的返回值构成一个集合（切片），作为MAP本身的返回值。
        // 该MAP的返回值被展开添加到实参区（平级 @SPREAD）。
```


### 7. 流程指令

普通编程语言中是以花括号限定语句块的范围，通过词法解析来编译和执行代码。栈脚本是指令值序列，需要实时解析并对阅读友好，为了提高效率，语句块的长度被作为附参附在了指令之后。

同时，附参的字节长度也限定了语句块的长度范围，这是一种严格约束，可以一定程度限制脚本结构的复杂性。

语句块的最终长度由解析器解析计算而来，书写时无需包含中括号的附参明示（那会很麻烦）。指令的子语句块即为该指令的关联数据。

指令值区间：`[60-67]`，8个。

```go
指令值  指令字      说明
-----------------------------------------------------------
60      IF{}(1)     真值执行
        // 附参：子语句块长度，uint8类型。
        // 实参：布尔值。
        // 实参值为true时执行子语句块。
        // 注记：
        // 会设置IF的状态，供后续可能的ELSE指令判断。
        // 例：
        //      ... EQUAL   // 比较结果入栈。
        //      IF{         // 栈顶值为true时执行子语句块
        //           TRUE PRINT  // 打印 true
        //      }
        // 说明：
        // - IF的条件由它的实参表达，在指令之前就已经计算好了。
        //   这是栈脚本栈式结构的特点。
        // - IF和ELSE并不需要紧邻，两者之间可以有其它普通语句。
        //   IF状态在同层级是共享的，后来的IF会覆盖之前的IF状态（影响ELSE逻辑）。

61      ELSE{}(1)   IF不满足时执行
        // 检查本层级IF状态值，如果IF为假则执行本语句块。
        // 附参：指令块长度，uint8类型。
        // 实参：无。
        // 注：
        // 连续的ELSE是可能的，它们相对于前面的IF状态判断自身的逻辑。
        // 虽然这看起来有点怪异。
        // 如果ELSE块很大，这可以是一种拆分策略。

62      SWITCH{}(2) 分支选择区
        // switch 语法块开启。
        // 附参：区块长度，uint16类型。
        // 实参：待对比值，任意类型。
        // 注记：
        // 会设置实参为 SWITCH 标的值，供后续 CASE 对比判断。
        // 提示：
        // 若标的值为true，可模拟 if/elseif/else 的逻辑。

63      CASE{}(1)   条件分支
        // 附参：语句块长度。
        // 实参：对比值，任意类型。
        // 实参与 SWITCH 标的值比较：
        // - 真：执行子语句块。
        // - 假：跳过子语句块。
        // 注：
        // CASE 块执行之后即结束 SWITCH 语法块。
        // 子块中可以用 BREAK 指令提前退出（子块未结束时）。
        // 例：
        // @POP                 // 将被设置为 SWITCH 标的值
        // SWITCH{
        //      ( POP + {99} )  // 表达式结果入栈
        //      CASE{           // 栈顶值为实参，与SWITCH标的值比较，相等则执行
        //          ...
        //          BREAK       // 可选（会自然退出）
        //      }
        //      {100} @EQUAL    // 多CASE不必紧邻，此为下一CASE实参
        //      CASE{           // 同前比较...
        //          ...         // 执行结束则switch结束
        //      }
        //      DEFAULT{...}    // 默认分支，抵达则无条件执行
        // }
        // 注意：
        // 多个平级CASE间可插入普通语句，这让条件计算更直观。
        // 如果某CASE执行，则SWITCH块就结束了，所以之后的语句就无效了。

64      DEFAULT{}(1)  默认分支
        // 无条件执行。
        // 附参：语句块长度。
        // 说明：
        // 其它CASE分支未执行时执行，只能在所有CASE之后。可选。

65      EACH{}(1)   迭代式循环
        // 对集合成员逐一迭代处理。
        // 附参：循环块长度。
        // 实参：可迭代类型。
        // 局部变量：
        // - ${Value}   // 当前条目数据
        // - ${Index}   // 当前循环下标，从0开始
        // - ${Array}   // 目标集合本身
        // - ${Total}   // 迭代条目总数
        // 注记：
        // 与集合类指令MAP/FILTER不同，这里全局数据栈是可见的。

66      BREAK       退出EACH或SWITCH
        // 实参：布尔值，可选。
        // 如果实参有值，则真值执行，假值略过。否则直接执行。
        // 自带判断逻辑，可省略简单的IF{}结构。
        // 例：
        // @POPS[10]        // 取栈顶10项打包待处理
        // EACH{
        //      ${Value} @{1000}  // 当前值和目标值
        //      GT                // 当前值是否大于1000，结果入栈
        //      @POP BREAK        // 取比较结果，真值结束EACH{}，假值忽略
        // }
        // 注：EACH开始后实参区已为空。

67      （保留未用）
```


### 8. 转换指令

脚本中的数据是一种准严格类型，大部分需要显式的类型转换。

指令值区间：`[68-77]`，10个。

```go
指令值  指令字      说明
-----------------------------------------------------------
68      BOOL        转换为布尔值：Bool
        // 实参：
        // - 字符串：""  => false; 非空串 => true
        // - 整数：  0   => false; 非零值 => true
        // - 空值：  nil => false;
        // - 切片：  []  => false; 非空集 => true

69      INT         转换为整数：Int
        // 实参：
        // - 布尔值：true => 1, false => 0
        // - 字符串：任意合法的整数字符串表示，支持千分位（,）分隔符。
        // - 浮点数：截断小数部分，超过int64/uint64上限的大数会出错。

70      BIGINT      转换为大整数：BigInt
        // 实参：
        // - 字符串：   任意合法的整数字符串表示。
        // - 字节序列： 按 Golang math/big 包要求。
        // - 布尔值：   true => 1, false => 0
        // - 整数：     简单转换，无要求。
        // - 浮点数：   截断小数部分。

71      FLOAT       转换为浮点数：Float
        // 实参：
        // - 布尔值：true => 1.0; false => 0.0
        // - 整数：  简单的类型转换，无要求
        // - 字符串：合法的浮点数或科学记数法表示。

72      STRING      转换为字符串：String
        // 实参：
        // - 布尔值：true => "true"; false => "false"
        // - 整数：  显示为十进制字符串。
        // - 序列：  视为UTF-8编码的字节序列。
        // - 浮点数：显示为带小数点数字或科学记数法表示。

73      BYTES       转换为序列：Bytes
        // 实参：
        // - 字符串：转换为字符串的UTF-8码值序列。

74      REGEXP      转换为一个正则表达式。
        // 用实参值创建一个正则表达式对象。
        // 实参：
        // - 字符串：正则表达式的字符串形式。

75      DATE        转换为日期类型
        // 用实参构造日期/时间对象。
        // 实参：
        // - 字符串：标准的时间格式串（RFC3339）。
        // - 整数：UNIX时间戳（毫秒数）。
        // 例：
        //      {1608883593536} DATE
        // 用整数值构造一个时间对象（2020-12-25T08:06:33.536Z）。
        //      TEXT{2020-12-25T08:06:33.536Z} DATE
        // 用字符串构造一个时间对象。

76-77   （保留未用）
```

> **注记：**
> 脚本 `SCRIPT` 类型并不能从其它类型转换过来，而应该明确地通过 `CODE{}` 指令引入。


### 9. 运算指令

有两种形式的运算指令：

1. 符号指令。操作数在符号两侧的常见形式，如：`{100} + {10}`。仅用于表达式内。
2. 命名指令。类似于函数的普通指令，操作数作为实参在指令之前，如：`{100} {10} ADD`。可用于表达式之外（结果自动入栈）。

指令值区间：`[78-100]`，23个。


#### 表达式

表达式是一个独立的运算单元，外部实参区和局部域对表达式内的指令是只读的。表达式中的指令可以正常获取实参，但其返回值只是一个操作数，而不会自动进入数据栈。

通常，表达式内只是一些值指令或简单取值类的指令，如 `{123}、POP、ENV、VAR、$[]` 等，但依然可以是复杂的函数类指令，它们从实参区或数据栈内取实参，运算的结果滞留于当前位置作为操作数，但这种编码方式并不友好。更好的方式是先执行这些复杂指令，让它们的结果进入数据栈或存入局部域，然后再在表达式中简单地获取它们。

表达式计算的最终结果会作为表达式指令本身的结果返回（并自动入栈），但这不包含内部的子表达式。

> **注：**
> 截取指令 `@` 和 `$` 在表达式内没有意义，但从局部域取值的 `${}` 依然可用，不过其自动添加到实参区的能力没有了。


#### 指令清单

```go
指令值  指令字      说明
-----------------------------------------------------------
78      ()(1)       表达式封装（根）
        // 内部可以包含子表达式，由下面的子表达式指令封装。
        // 内部的计算相对独立，可以从实参区和局部域取值但赋值（@, $）非法。
        // 附参：表达式长度。
        // 实参：无。
        // 返回值：任意类型，单值。
        // 例：
        // ( POP + {100} )  栈顶值加100，结果值返回自动入栈。
        // ( POP + ${100} ) 错误。无法添加局部变量（且 ${100} 也无返回值）
        // ( POP + $[0] )   正常。$[0] 为取值而非赋值
        //
        // 提示：
        // 顶层的根表达式与普通指令一样，返回值会自动入栈，
        // 因此它前面也同样可以使用取值指令（@, $）拦截结果。
        // 如：
        // $( POP + {100} )  将运算结果放入局部域

79      ()(1)       子表达式&优先级分组
        // 仅存在于根表达式之内，如 ( ...() ) 内部的括号。
        // 附参：子表达式长度。
        // 实参：无。
        // 返回值：任意类型，表达式内部使用。
        // 例：
        //      ( {1.5} * (POP + {100}) )
        // 内部的子表达式的结果只是一个操作数（留在原地）。


// 符号指令：
// 双操作数。仅用于表达式内部。
80      *           乘
81      +           加
82      -           减，或取负
83      %           模（正负号跟随左操作数，同Golang）
84      /           除

85      <<          左移位
86      >>          右移位
87      &           位与：AND
88      |           位或：OR
89      ^           位异或（XOR）
        // 实参在指令前后两侧。
        // 例：
        //      ( {100} + POP * {1.5} / {2} )
        // 注意运算符优先级。
        // 运算符之间的空格是可选的。


// 命名指令：
// 双实参。可用于表达式内外。
90      MUL         乘：MUL(x, y) => x*y
91      ADD         加：ADD(x, y) => x+y
92      SUB         减：SUB(x, y) => x-y
93      MOD         模：MOD(x, y) => x%y
94      DIV         除：DIV(x, y) => x/y
        // 实参1：支持目标操作的类型。
        // 实参2：同上。
        // 返回值：相应类型，单值。
        // 例：
        // {32} {100} MUL    入栈32和100，取栈顶2项相乘
        // @POP @{100} MUL   先取出到实参区后计算。
        // @POP {100} MUL    错误。实参区只有1个值（参数不足）。
        //
        // 例：
        //      ( {100} + MUL )
        // 表达式内 MUL 从外部实参区或数据栈取实参，但这里不直观。


// 命名指令：
// 单实参。可用于表达式内外。
95      NEG         取负：-x  // Int, Float
96      NOT         取反：!v  // Bool
        // 实参：目标操作数。
        // 例：
        // {0} PEEK NEG     取栈底项值，返回其负数
        // {123} BOOL NOT   结果为 false


// 命名指令：
// 多返回值，仅用于表达式外。
97      DIVMOD      除并求余
        // 实参1：支持该操作的类型。
        // 实参2：同上。
        // 返回值：商和余数，2个值。
        // 值1：x / y
        // 值2：x % y
        // 返回值自动展开到接收域。

98      DUP(1)      复制
        // 复制目标数据，返回值自动展开到接收域。
        // 附参：复制的份数，uint8类型。
        // 实参：目标项数据。
        // 返回值：原值+复制的条目，不定数量。
        // 例：
        // DUP[1]       取出栈顶项复制1份，与原值同时返回（共2份）。效果同 TOP。
        // DUP[2]       取出栈顶项复制2份，与原值同时返回（共3份）。
        // DUP[0]       没有复制，返回原值（实际上没做啥）。
        // $[0] @DUP[1] 引用局部域首个成员，复制后返回2份自动展开到实参区。
        // 注：
        // 适用任意数据类型，但仅为浅复制，主要用于Bytes和String。

99-100  （保留未用）
```

**注意：**
> `ADD, +` 指令对于字符串（`String`）和序列（`Bytes`）是连接操作。


### 10. 比较指令

两个或多个操作数执行比较，返回一个布尔值（单值）。

指令值区间：`[101-108]`，8个。

```go
指令值  指令字      说明
-----------------------------------------------------------
101     EQUAL       相等（a == b）
102     NEQUAL      不相等（a != b）
103     LT          小于（a < b）
104     LTE         小于等于（a <= b）
105     GT          大于（a > b）
106     GTE         大于等于（a >= b）
        // 实参1：支持该比较的类型。
        // 实参2：同上。
        // 返回值：true 或 false。

107     WITHIN      范围判断
        // 实参1：下边界值（包含）。
        // 实参2：上边界值（不包含）。
        // 实参3：待比较值。
        // 例：
        //      @{0} @{240} ENV{Height} WITHIN
        // 判断当前交易所在理想块高度是否为在第一天之内。

108     （保留未用）
```

**注：**
> 序列（`Bytes`）类型的大小比较按从左到右的逐字节进行。布尔（`Bool`）类型仅适用 `EQUAL, NEQUAL` 指令。


### 11. 逻辑指令

实参需为布尔类型，返回值也是一个布尔值（`true` 或 `false`）。

指令值区间：`[109-112]`，4个。

```go
指令值  指令字      说明
-----------------------------------------------------------
109     BOTH        两个都为真（&&）
        // 逻辑AND，是否两个值都为 true。
        // 实参1：一个布尔值。
        // 实参2：一个布尔值。
        // 返回值：一个布尔值。
        // 例：
        // BOTH PASS  取栈顶两个值，都为真时通过。

110     EVERY       全部为真（类 &&）
        // 逻辑AND，是否全部成员都为 true。
        // 实参：一个布尔值集合。
        // 返回值：一个布尔值。
        // 例：
        // POPS[3] EVERY  栈顶3项打包，检查成员是否都为 true。
        // TOPS[0] EVERY  栈顶为一个空集，返回 true。

111     EITHER      两个中任一为真（||）
        // 逻辑OR，两者中是否有其一为 true。
        // 实参1：一个布尔值。
        // 实参2：一个布尔值。
        // 返回值：一个布尔值。
        // 例：
        // EITHER PASS  取栈顶两个值，任一为真时通过。

112     SOME(1)     部分为真（||, &&）
        // 逻辑OR，全部成员中是否至少 n 个为 true。
        // 附参：为真的最低数量（n）。
        // 实参：一个布尔值集合。
        // 返回值：一个布尔值。
        // 例：
        // SOME[2]  需2个以上为真（含2个）
        // SOME[1]  至少1个为真，较常用
        // SOME[0]  无条件为真。同空集之于EVERY
        // 例：
        // TOPS[0] SOME[1]  实参为空集，返回 false
        // TOPS[0] SOME[0]  返回 true
```


### 12. 模式指令

指令序列的模式匹配，用于验证目标脚本是否符合特定的逻辑序列。在排除掉可忽略的指令后，目标指令序列需与模式序列完整匹配。如果匹配失败，等同于验证失败。

一个模式序列通常称为一个模型。一个拥有广泛共识的模型可能会被预先发布在一笔管理者交易中供分享（作为 `GOTO` 目标）。

模式匹配很有用处，比如在链间兑换时确认对方的预支付脚本是否有效，在选举子链中对投票内容的格式做验证（以免选票无效），甚至由中间件执行匹配提取信息以执行链外的业务，实现无人工审核的自动化流程。

总的来说，模式匹配可以让某件事在*下一步具体行动前*得到合规性确认。

指令值区间：`[113-123]`，11个。

```go
指令值  指令字          说明
-----------------------------------------------------------
113     MODEL<>{}(1,2)  创建模式匹配区
        // 开启一个解析子环境，等待对实参字节序列执行模式匹配。
        // 附参1：可忽略指令清单长度，<>内为逗号分隔的指令列表。
        // 附参2：模式区长度，{}内包含了模式匹配序列。
        // 实参： 待测试的指令序列（Script）。
        // 返回值：一个切片，包含 # 和 & 两个指令收集的值。
        // 注意：
        // - 可忽略指令清单长度指占用的字节数，而非指令的个数。
        // - 不方便用名称表达的可忽略指令（如值指令），可用指令值表示。
        // - 忽略是指整个指令，包含附参、关联数据和其读取的实参区（如果需要读取）。
        // - 可忽略指令也可出现在模式区内，但会视为普通指令。
        // - 返回的切片并不会自动展开。
        // 例：
        // 支付脚本：
        //      TOP FN_HASH160 DATA{<pkHash>}
        //      @TOP PRINT              // @TOP 为 PRINT 的实参区实参
        //      EQUAL PASS FN_CHECKSIG PASS
        // 模型：
        //      CODE{ ... }                         // 封装上面的脚本（指令值序列）
        //      MODEL<PRINT, INPUT, OUTPUT>         // PRINT 将被忽略
        //      {
        //          TOP FN_HASH160                  // 严格匹配（原样）
        //          DATA[20]{?}                     // 关联数据长度固定，内容任意
        //          #[4]                            // 取 DATA{} 关联数据。注：@TOP PRINT 已被忽略
        //          EQUAL PASS FN_CHECKSIG PASS     // 严格匹配（原样）
        //      }
        //      @SPREAD OUTPUT BUFDUMP  // 模型之外的普通代码。上面MODEL{}收集的数据已经自动入栈。
        // 说明：
        // - #[4] 指令提取了匹配目标的关联数据（公钥哈希）。
        // - 打印指令连同其 @TOP 实参取值被忽略，因此模式中看不到它们。
        // - 模式匹配结束后，MODEL指令返回了提取的公钥哈希。
        // 注：
        // 如果一个未知脚本匹配上面的模型，就说明它的支付逻辑正常。


// 以下为局部指令，仅在 MODEL{} 内有效。

114     #(1)        取值指示（指令）
        // 针对前一个指令匹配的目标，取目标的不同部分的值。
        // 附参：目标值标识。
        // 0001 - 指令本身。(1)
        // 0010 - 附参部分。(2)
        // 0100 - 关联数据。(4)
        // 1000 - 取值实参（如果需要，实参区或数据栈）。(8)
        // 可合并标识：
        // 0011 - 指令和附参。(3)
        // 0101 - 指令和关联数据。(5)
        // 0110 - 附参和关联数据。(6)
        // 0111 - 指令整体：指令、附参和关联数据。(7)
        // 1111 - 目标整体，含取值实参的值。(15)
        // 例：
        // MODEL<...> {
        //      DATA[32]{?} #4      // 提取前面 DATA 匹配目标的数据段。
        // }
        // #4 是 #[4] 的简写形式。
        // 注：
        // 提取的值会放入一个内部队列，作为MODEL最终的返回值。

115     ?           指令通配
        // 目标指令可为任意指令。含附参和关联数据，不含实参。
        // 例：
        // ?    当前目标位置为任意一个指令。

116     ?(1)        指令局部通配
        // 用跟随指令来和目标作比较，附参指定了通配的部分。
        // 附参：位置标识。
        // 0000 0001    关联数据任意。(1)
        // 1000 0000    第1个附参任意，其它附参严格匹配。(128)
        // 0100 0000    第2个附参任意，其它附参严格匹配。(64)
        // 0010 0000    第3个附参任意，其它附参严格匹配。(32)
        // 0001 0000    第4个附参任意，其它附参严格匹配。(16)
        // 0000 1000    第5个附参任意，其它附参严格匹配。(8)
        // 0000 0100    第6个附参任意，其它附参严格匹配。(4)
        // 0000 0010    第7个附参任意，其它附参严格匹配。(2)
        // 注：
        // 最多支持7个附参的通配标记，各个通配位可任意同时设置。
        //
        // 例：
        // ?[1] DATA[32]    跟随指令的关联数据任意（但必须为32字节长）。
        // ?1 DATA[32]      同上。
        // DATA[32]{?}      同上。阅读友好，由解析器处理实际位置。
        // TEXT[300]{?}     匹配300字节长任意文本。注：将被解析为 TEXT{}(2) 指令。
        // 注意：
        // DATA[?]{?}       附参任意，关联数据任意。匹配任意 DATA{} 值。
        // !Bytes           效果同上。匹配字节序列型任意值（! 见下）。
        //
        // 例：
        // ?128 INOUT[3]    首个附参任意，第二个附参确定。
        // INOUT[?, 3]      同上，可读性更好。
        // (?)              目标是一个表达式指令。
        // ({10} + (?))     目标表达式内该位置的子表达式内容任意。
        //
        // 例：
        // IF[60]{?}        匹配if指令，关联的语句块长60字节，内容不限。
        // IF[?]{?}         匹配一个if指令，长度和内容都任意。
        // IF[?]{           匹配一个if指令。子语法块正常延续测试。
        // IF{              同上。简化写法。
        //
        // 例：
        // @ ?1 DATA[32]    匹配实参取值，任意32字节序列。
        // @ DATA[32]{?}    同上。@ 之后的空格可选。
        // @ !Bytes         匹配字节序列取值指令（两个 DATA{}）。
        // $ POP            匹配 $POP 复合指令，空格可选。
        // $[?]             匹配局部域任意取值。
        // ?128 $           同上。

117     !{TYPE}(1)  类型匹配
        // 目标为特定类型的值指令。
        // 附参：类型名。
        // - Bool   布尔值
        // - Int    整数（7个）
        // - BigInt 大整数
        // - Float  浮点数（2个）
        // - Bytes  字节序列（2个）
        // - String 字符串（2个）
        // - RegExp 正则表达式（/.../）
        // - Date   日期/时间（TIME{}）
        // - Script 脚本代码（CODE{}）
        // 例：
        // !{Bool}  目标必须是布尔类型（true|false）。
        // !Bool    同上，可省略花括号。
        // !Bytes   匹配两个 DATA{} 指令。
        // !String  匹配两个 TEXT{} 指令。
        // !Script  匹配 CODE{} 指令。
        // !Int     匹配任意整数。
        // !Float   匹配任意浮点数。

118     !{}(~,~)    整数值范围匹配
        // 限定目标值在设定的范围之内，不包括上界值。
        // 附参1：下界值，变长整数。
        // 附参2：上界值，变长整数。
        // 例：
        // !{0, 1024} 限定目标值：0 ≦ n < 1024
        // !{0, 128}  限定目标值：0 ≦ n < 128（目标通常是 {}(1) 指令）。
        // 注：
        // - 整数由多个指令表达，范围匹配并不要求目标具体是哪个指令，
        //   只要值满足要求即可。
        // - 不支持大整数（BigInt）范围匹配。

119     !{}(8,8)    浮点数值范围匹配
        // 限定目标值在设定的范围之内，不包括上界值。
        // 附参1：下界值，8字节表达。
        // 附参2：上界值，8字节表达。
        // 例：
        // !{0, 1.0}  目标为小于1.0的任意正浮点数。
        // 注意：
        // 两个边界值必须至少有一个是浮点数表示，否则会被识别为整数范围。

120     RE{/.../xx}(1)  正则匹配
        // 对文本目标执行正则表达式匹配。
        // 附参：此处正则式的内容长度。
        // 注意：
        // 不是检查目标是否为合规的正则表达式指令，而是对目标文本执行正则式测试，
        // 如果目标文本符合这里的正则式，则视为正确。
        // 匹配的结果值可以通过下面的 & 指令（依附关系）获取。

121     &(1)        取值指示（正则匹配）
        // 配合上面的 RE{/.../} 指令使用，针对其匹配目标，取匹配值或子匹配式的值。
        // 附参：正则表达式的取值序位。
        // 这是模式内除 # 指令外的第二个取值指令，它们的取值共同构成 MODEL{} 的返回值。
        // 注意本指令需要紧随其属主指令 RE{/.../} 之后。
        // 例：
        // MODEL<...> {
        //      RE{/[a-z]+/i} &[0]  取目标字符串中匹配的单词
        // }
        // 例：
        // RE{/[a-zA-Z]+/} &0       效果同上。
        // RE{/Ver-(\d+)/} &[1]     提取主版本号（首个子表达式匹配项）
        // RE{/Ver-(\d+)/} &1       同上。简写形式
        // 注：
        // 上面示例中省略了上级封装指令 MODEL<>{}。
        //
        // 注记：
        // - 如果前面的 RE{/.../} 匹配没有成功，模式将不会通过，
        //   因此后面的本取值指令也就不会被执行了。
        // - 本指令为目标脚本的数据提取提供了一个便利，但目标必须首先得匹配。

122     ...         任意指令段匹配
        // 匹配任意指令序列（包括附参和数据）。
        // 通配只限于当前层级（同域），子语句块作为一个整体对待。
        // 贪婪匹配模式。
        // 例：
        // 目标脚本：
        //      SYS_TIME{Stamp} {<expireTime>} GT
        //      @TOP PRINT              // 1
        //      IF{
        //          @POP PRINT
        //      }
        //      TRUE
        //      IF{
        //          TEXT{Hello in IF}   // 2
        //          @TOP PRINT          // A
        //      }
        //      TEXT{done!}
        //      @TOP PRINT              // B
        //      @POPS[] NOP
        // 模型：
        // MODEL<>{
        //      SYS_TIME{Stamp}         // 换行没问题
        //      {<expireTime>} GT
        //      ...                     // 1
        //      IF{
        //          ...                 // 2
        //          @TOP PRINT          // A
        //      }
        //      TEXT{done!}
        //      @TOP PRINT              // B
        //      @POPS[] NOP            // 终点完整匹配
        // }
        // 1.
        // 第一个...匹配“@TOP PRINT IF{...} TRUE”。
        // 2.
        // 第二个...匹配「TEXT{Hello in IF}」，到A为止，不会跨层级到B。
        //
        // 模型：
        // MODEL<>{
        //      SYS_TIME{Stamp}
        //      {<expireTime>} GT
        //      ... IF{?}           // 匹配上面第二个IF（贪婪）
        //      ...                 // 剩余匹配
        // }
        // 注意：
        // 最后的...是必须的，这是匹配完整性要求（匹配到脚本结束）。
        //
        // 参考：
        // 如果将嵌套构造为树结构，是一个广度优先的测试。
        // 但不同域内的模式取值（#）依然按源码顺序（深度优先）收集。

123     （保留未用）
```


#### 附：模式匹配包含的内容

- **位置匹配**：滤除掉可以忽略的指令后，位置一一对应（位置记数不包含可忽略指令）。
- **指令匹配**：指令相同即为匹配。如果指令为值指令，则也隐含了类型匹配逻辑。
- **附参匹配**：在指令匹配的前提下，附参参与匹配。
- **数据匹配**：在指令匹配的前提下，指令关联的数据也参与匹配。
- **范围限定**：整数和浮点数的范围匹配，内部的细分类型被忽略。
- **类型匹配**：对目标的数据类型执行匹配，值任意。
- **正则匹配**：支持 `RE{/../}` 对文本目标进行正则匹配测试，并可通过 `&` 指令提取匹配结果。

> **注：**
> 流程类指令（`IF{}`、`SWITCH{}` 等）在有子内容匹配时，附参会被忽略。


### 13. 环境指令

脚本的运行处在一个逐层嵌套的环境里：`系统环境 > 交易域 > 校验域 > 脚本域 > 局部域`，其中前者是后者的父域。

1. **系统环境**。节点的运行时环境。包含节点能提供的一些系统级信息。
2. **交易域**。  一笔交易可包含多个输入和输出，这里可访问跨脚本的兄弟输入和输出。
3. **校验域**。  当前脚本的校验环境，包含 `GOTO` 跳转到的脚本的验证。
4. **脚本域**。  当前脚本的全局环境。`JUMP` 嵌入的子脚本与当前脚本共享此域，但 `GOTO` 跳转的脚本拥有自己的脚本域。
5. **局部域**。  当前脚本按语法块分层的存储区，包含顶层和嵌套子块都有。这些域是私有的，无法互访。

> **注：**<br>
> 只有当交易的输出（锁定）脚本需要作为新交易的输入时，它才需要被验证。<br>
> 证据中的输出（识别）脚本也是在客户端需要确认它（另一种意义上的输入）时，才需要验证。<br>


指令值区间：`[124-134]`，11个。

```go
指令值  指令字      说明
-----------------------------------------------------------
124     EVN{}(1)    交易域和系统环境取值
        // 附参：目标名称的标识值。
        // 返回值：目标成员值。
        // 书写时通常使用标准的名称而不是数值下标。
        //
        // 交易域：
        // 脚本所在的源交易：
        // 注：在它们被定义的时候并不明确，但被使用验证时已知。
        // - Height     理想块高度（按时间戳算）
        // - Time       理想块时间戳
        // - RealHeight 交易打包进的实际区块的高度
        // - TxID       交易ID
        // - Timestamp  交易时间戳
        // - Amount     交易金额（可计算得知）
        //
        // 针对当前正在验证的交易：
        // 注：对于定义这些取值的脚本来说，是指将来花费它们的交易。
        // - InTotal    输入项总数
        // - InAmount   输入总金额
        // - OutTotal   输出项总数
        // - OutAmount  输出总金额
        //
        // 在跳转到的脚本内：
        // - XFrom      GOTO/JUMP 来源脚本信息集
        // - XCount     当前跳转/嵌入计数
        // - XGoto      是否从 GOTO 指令跳转过来
        // - XJump      是否由 JUMP 指令引入
        // 例：
        // EVN{RealHeight} 获取当前输入所在交易的真实区块高度。
        //
        // 系统环境：
        // - BlockHeight 区块链当前最新高度
        // - BlockTime   当前最新区块创建的时间戳
        // - LimitStack  栈高度上限（256）
        // - LimitScope  局部变量域上限（128）
        // - ……

125     OUT{}(1,1)  输出项取值（交易域）
        // 针对当前交易的输出项集（即正在验证的交易）。
        // 可用于源锁定脚本限定其花费的目标（新的输出）。
        // 附参1：输出项序位（起始值0）。
        // 附参2：输出项中的成员的标识。
        // 返回值：目标成员值。
        // 成员：
        // - Amount      币金数量
        // - Receiver    接收者
        // - Description 凭信描述，适用凭信交易
        // - Count       凭信转移计数，适用同上
        // - Title       证据标题，适用证据交易
        // - Content     证据内容，适用同上
        // - Attachment  附件ID，适用凭信和证据交易
        // - Script      输出脚本自身
        // - Index       在输出集中的序位，从0开始
        // 例：
        //      OUT[0]{Amount}
        // 取当前在验交易中首个输出项的币金数量。
        // 这并不是一个在输出中实际存在的数值，而是验证节点推导计算出来的值。
        //
        // 注记：
        // 输出项序位仅用1字节表示，虽然一笔交易中的输出项可能更多。
        // 因此新交易的构造者可能需要对输出项的顺序做特意安排。
        // 注意：
        // 如果输入的锁定脚本中使用了本指令，则验证节点就需要详细查看交易的输出部分了。

126     IN{}(1)     输入项取值（校验域）
        // 大部分与上面输出项取值的字段名相同。
        // 因为输入项就是前阶交易中一个具体的输出项，所以无需序位附参。
        // 附参：取值的成员标识。
        // 返回值：目标成员值。
        // 成员：
        // - Amount      币金数量
        // - Receiver    接收者
        // - Description 凭信描述
        // - Count       凭信转移计数
        // - Title       证据标题
        // - Content     证据内容
        // - Attachment  附件ID
        // - Script      输入脚本自身
        // - Timestamp   源交易的创建时间戳
        // - Signsum     合法签名的数量
        // 注：
        // 当前交易的输入项实际上是上一笔交易的输出项。

127     INOUT{}(1,1) 输入项的兄弟输出项取值（系统环境）
        // 即输入项所在源交易的兄弟输出项取值，可建立不同输出之间的关联。
        // 附参1:目标输出项的序位（起始值0）。
        // 附参2:目标成员的标识。
        // 返回值：目标成员值。
        // 成员：
        // 参考前 OUT 指令。
        // 注记：
        // 这需要验证节点解析源交易的其它输出项，通常仅在有需要时才去做。

128     MULSIG(1)   多重签名序位确认（校验域）
        // 目标序位的签名合法时返回true，否则返回false。
        // 附参：目标序位。即签名者序号，从0开始。
        // 返回值：布尔值。
        // 仅适用多重签名输入，在GOTO到的脚本中也可用。
        // 例：
        //      MULSIG[2]
        // 确认多重签名哈希列表中第3序位者参与签名。
        //      MULSIG[0] MULSIG[1] MULSIG[2] @POPS[3] SOME[2] PASS
        // 模拟2/3多重签名验证。

129     VAR(1)      全局变量取值（脚本域）
        // 附参：目标变量位置下标。
        // uint8 类型，最多支持256个变量。
        // 与局部域不同，此为变量逻辑，可被定位覆盖赋值。
        // 返回值：目标置位的值，单值。
        // 例：
        // @VAR[0] 取全局变量段里首个位置值添加到实参区。
        // VAR[10] 取全局变量段里第11位置下标的值入栈。
        // 注：
        // 本指令属于脚本域，不跨GOTO。
        // JUMP指令跳转的脚本共享同样的脚本域，因此会相互影响。

130     SETVAR(1)   全局变量赋值（脚本域）
        // 对脚本域的全局变量赋值，变量定位采用位置下标，可覆盖。
        // 可由上面的 VAR 指令读取。
        // 附参：变量位置下标。
        // 实参：任意类型，单值。
        // 返回值：无。
        // 例：
        // {123} SETVAR[1]    将栈顶的值 123 存入全局变量段的第2个位置。
        // {1.5} SETVAR[255]  将浮点数 1.5 存入全局变量段的最后一个位置。
        // $VAR[1]            读取上面存储的 123 添加到当前局部域。

131     SCRIPT      脚本指令序列获取（脚本域）
        // 获取脚本的指令序列本身，主要用于模式匹配时用。
        // 起点：脚本头部，包括解锁部分。
        // 终点：当前指令位置（不含本指令）。
        // 注：
        // 指令针对脚本代码本身，因此 GOTO 和 JUMP 也仅是一个指令。
        // 这两个指令仅在执行时才与它定位的子脚本有关。

132-134 （保留未用）
```


### 14. 工具指令

包含一些基础性并常用的功能性指令。

指令值区间：`[135-149]`，15个。

```go
指令值  指令字      说明
-----------------------------------------------------------
135     EVAL        子脚本执行
        // 实参：脚本指令值序列。
        // 返回值：无。
        // 外部嵌入脚本的方式：
        // - 解锁脚本。公共逻辑，任何节点都需要执行。
        // - 缓存区导入。私有逻辑，需要部署的节点自行处理。
        // - GOTO/JUMP 引入，公共逻辑。
        // 提示：
        // 高消耗的脚本可能导致不受欢迎而被拉入黑名单。
        //
        // 安全性：
        // 系统可能会对嵌入的子脚本长度实施限制，如：
        // - 实参长度 < 256字节。
        // - 实参内禁止 EVAL（二次使用）。

136     MATCH(1)    正则匹配取值
        // 对字符串进行正则匹配，取匹配值或子匹配的值。
        // 附参：正则表达式的取值序位。
        // 实参1：目标字符串。
        // 实参2：一个正则表达式。
        // 返回值：一个单值或一个切片，视正则式是否拥有g标志。
        // 例：
        // ... /[a-z]+/i MATCH[0]     取整个正则式匹配的结果（$0）
        // ... /Ver-(\d+)/ MATCH[1]   提取首个子表达式匹配项（$1，版本号）

137     SIZE        集合大小
        // 实参：一个集合。可用len()计算的对象。
        // 返回值：一个整数。

138-139 （保留未用）

140     ITEM        成员条目获取
        // 获取数据集合中的单个成员。
        // 实参1：目标集，切片或字典（map[string]value）。
        // 实参2：成员位置下标或键名，数值支持负数从末尾算起。
        // 返回值：目标成员值，单值。
        // 例：
        //      POPS[5] PEEK[0] ITEM EQUAL PASS
        // - 取栈顶5项打包为一个集合入栈。
        // - 取栈底成员值（可能由解锁实参传入）入栈。
        // - 获取集合内目标位置的值入栈。
        // - 比较此时的栈顶2项是否相等（5个成员已弹出，最新入栈为拣取值）。
        // - 相等则验证通过。

141     RANGE(1)    创建连续数值序列
        // 步进值强制为1，创建一个递增的连续值序列。
        // 附参：序列长度（单元个数）。0值创建一个空切片。
        // 实参：起始值。
        // 返回值：一个切片。
        // 例：
        // {10} RANGE[5]  // 生成 [10, 11, 12, 13, 14]。
        // {0} RANGE[]    // 生成 []，实参仅为占位（必需）。

142     RANGE       创建数值序列
        // 同上指令，但参数完整并全部由实参给定。
        // 实参1：起始值。
        // 实参2：步进值。
        // 实参3：序列长度（单元个数）。
        // 返回值：一个切片。
        // 例：
        // @{10} @{10} @{5} RANGE  // 生成 [10, 20, 30, 40, 50]。
        // 注记：
        // 源码解析可观察RANGE是否携带中括号附参来分别。

143-149 （保留未用）
```


### 15. 系统指令

执行系统级功能的指令。

指令值区间：`[150-159]`，10个。

```go
指令值  指令字          说明
-----------------------------------------------------------
150-153 （保留未用）

154     SYS_TIME{}(1)   取全局时间对象的属性值
        // 全局时间对象是客户端真实的当前时间，只读。
        // 附参：目标属性的标识值。
        // 每一个属性被规划为固定的序号位置，但也包含标准的命名。
        // 如果采用字符串名称，需书写在花括号内。
        // 属性：
        // - Stamp      当前时间戳（毫秒）
        // - Year       年数（4位）
        // - Month      月次/年（1-12）
        // - YearDay    日次/年（1-365|366）
        // - Day        日次/月（1-31）
        // - WeekDay    日次/周（0-6）
        // - Hour       时数/日（0-23）
        // - Minute     分钟数/时（0-59）
        // - Second     秒数/分钟（0-59）
        // 例：
        // SYS_TIME{Stamp} 获取当前系统时间戳值入栈。
        // SYS_TIME[0]     同上（假设Stamp的序号为0）。

155     SYS_AWARD       兑奖验算
        // 检查当前交易所在区块之后240个区块的兑奖槽，计算奖金兑现。
        // 规则：
        //      确认数   兑现比例
        //      ----------------
        //      1        20%
        //      2        40%
        //      3        60%
        //      4        80%
        //      5        100%
        // 说明：
        // 因为是统计之后的区块的兑奖确认数，奖励必须超过一天才能兑现。
        // 所以当前铸造者需要分析前面240个区块的兑奖槽并计算-241号区块的奖金截留。
        // 用户能够取走的奖金和将要被截留的部分可能各自计算（但应互为契合）。

156-159 （保留未用）
```


### 16.函数指令

指令值区间：`[160-209]`，50个。


#### 基础函数集

定义一些常用的基础性函数。

> **注意：**
> 这里的指令书写按普通函数定义的方式，实参可从小括号内的文本体现出来，更为直观。

```go
指令值  函数名（参数序列） => 返回值类型
-----------------------------------------------------------
160     FN_HASH256( data Bytes ) => Bytes
        // 实参：任意字节序列。
        // 哈希计算，可用于哈希屏障保护。
        // 返回值：32字节长。

161     FN_HASH160( data Bytes ) => Bytes
        // 实参：任意字节序列。
        // 哈希计算，主要用于公钥的哈希计算。
        // 返回值：20字节长。
        // 注：
        // 字节形式的公钥哈希地址简称为公钥地址。

162     FN_BASE58( data Bytes ) => String
        // 实参：任意字节序列
        // 目标字节序列为编码为 Base58 字符串。

163     FN_BASE32N( data Bytes ) => String
        // 定制版Base32编码，
        // 实参：任意字节序列。
        // 后缀N表示定制数字 456789（标准格式为 123456）
        // 注记：
        // 标准的数字1在某些字体下，字形与字母I相似（易混淆）。

164     FN_ADDRESS( pbhash Bytes ) => String
        // 实参：公钥哈希地址。
        // 将字节格式的公钥哈希地址编码为文本地址（Base58），
        // 会前置专有标识，包含地址验证功能。
        // 注意：
        // 文本形式的公钥地址与字节格式的公钥地址是一样的，
        // 文本形式主要用于书写阅读，交易中则实为字节格式的哈希序列。
        //
        // 编码：
        // 1. 对公钥地址再执行一次哈希运算，取末尾4字节为校验码。
        // 2. 在公钥地址之后附上校验码，编码为 Base58 形式，即为公钥的文本地址。
        // 校验：
        // 1. 将公钥的文本地址解码为字节序列。
        // 2. 截取序列的最后4字节为校验码，前段即为公钥地址。
        // 3. 对前段的公钥地址执行一次哈希，取末尾4字节与校验码对比，相同则地址合法。
        //
        // 前缀字符参考：
        // - 1  普通账户地址，单签名。
        // - 2  1/2签名账户地址。
        // - 3  2/3签名账户地址专属。
        // - 0  定制多重签名账户地址（非2和3类型）。

165     FN_CHECKSIG( sig, pubkey Bytes ) => Bool
        // 单签名验证。
        // 实参：（签名，公钥）

166     FN_MCHECKSIG( sig Bytes, n, t byte, pubkeys, restpkhs []Bytes ) => Bool
        // 多重签名验证。
        // 实参：（签名, n/t配比, 公钥集, 剩余公钥地址集）

167-199 （保留未用）

200     FN_PRINTF( fmt, val, ... ) => nil
        // 格式化打印（格式化串，实参1，实参2，...），同 go:fmt.Printf。
        // 实参：不定数量。

201-207 （保留未用）
```


#### 扩展函数集

两个扩展类指令引入更多可能需要的函数，空间已十分可观。

```go
指令值  指令字          说明
-----------------------------------------------------------
208     FN_A(1)         基础扩展（1字节空间）
        // 1字节的附参可包含256个扩展函数。

209     FN_B(2)         高级扩展（2字节空间）
        // 2字节的附参可包含64k个扩展函数。
```


### 17.模块指令

模块的成员以标准的名称书写在花括号内，附参多为1个字节，用于索引成员函数。

通常，模块如果需要创建一个表示自身的对象，应由首个成员 `Create` 实施。作为约定，如果其它成员函数需要使用该对象，应作为首个参数传入。

指令值区间：`[210-249]`，40个。

```go
指令值  指令字          说明
-----------------------------------------------------------
210     MO_RE{}(1)      正则表达式模块
        // 处理正则表达式对象，对象作为首个参数传入。
        // 可由 /.../ 指令创建，或由 REGEXP 指令转换而来。
        // 方法：
        // - （待定）

211     MO_DATE{}(1)    日期对象模块
        // 处理日期/时间对象，对象作为首个参数传入。
        // 可由 TIME{} 指令创建，或由 DATE 指令转换而来。
        // 方法：
        // - （待定）

212     MO_MATH{}(1)    数学运算模块
        // 例：
        // MO_MATH{Abs} 计算实参的绝对值。
        // 成员：
        // - Abs    绝对值：|-4| => 4
        // - Pow    幂乘值：x**y
        // ...

213     MO_CRYPT{}(1)   加密运算模块
        // 对称加密：
        //
        // 非对称加密：
        //

214-248 （保留未用）

249     MO_X(1)         标准扩展引用
        // 1字节支持扩展到256个模块，似已足够。
        // 如需更多模块支持，可以使用扩展区指令（EX_BASE 或 EX_BASE2）。
```


### 18. 扩展指令

最后的8个指令空间位用于扩展指令区。

指令的扩展籍由附参实现，主要包含了2个预置的引用指令（`EX_BASE`，`EX_BASE2`）：附参定位了扩展的指令本身，而该扩展指令是一个完整的逻辑，可以包含其自身的附参。

这种扩展方式实际上是一种 **附参递进** 的逻辑，理论上可以无限递进、深层嵌套（很难看，不过实际上也用不着）。

指令值区间：`[250-255]`，6个。

```go
指令值  指令字          说明
-----------------------------------------------------------
250     EX_BASE(1)      基础扩展引用（1字节空间）
        // 1字节的附参可包含256个扩展指令。

251     EX_BASE2(2)     基础扩展引用（2字节空间）
        // 2字节的附参可包含64k个扩展指令。

252     （保留未用）

253     EX_PRIV(1)      私有扩展引用（1字节空间）
        // 私有范畴，公共节点简单忽略（不执行）。
        // 通常由有特定需求的应用使用。
        // 注：
        // 如果在模式语句块内使用，则遵循正常的模式匹配逻辑，
        // 这不会导致指令运行。

254     EX_PRIV2(2)     私有扩展引用（2字节空间）
        // 同上。较大扩展空间容量（64k）。

255     （系统保留）
```


-------------------------------------------------------------------------------

上一篇：[脚本系统设计](5.脚本系统设计.md)<br>
下一篇：[附1：组队校验](附1.组队校验.md)<br>
