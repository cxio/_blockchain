//////////////////////////////////////////////////////////////////////////////
Copyright (c) 2019 - 2021 @cxio/blockchain

    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.3
    or any later version published by the Free Software Foundation;
    with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
    A copy of the license is included in the section entitled "GNU
    Free Documentation License".
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

## 基础指令集

> **注**：下面的代码并非Go语言代码，仅便于显示友好。


### 1. 值指令

在脚本中作为一个实际的值存在，直接自动入栈，没有实参。

对于前面3个值指令（**0-2**），指令值本身即代表其表达的值。对于前段的数值类值指令，附参即为其数据。对于后面的复杂值类型，小括号内的数字指示了其数据的长度（字节数）。

指令值区间：`[0-21]`，22个。

```go
指令值  指令名      说明
-----------------------------------------------------------
0       NIL         空值
        // 即Go语言中的 nil 值。

1       TRUE        真值（true）
2       FALSE       假值（false）
        // 类型：Bool，布尔值。
        // 在源码中书写指令名，解析为指令值，解码为所代表的值。
        // 例：
        // TRUE 解析为脚本指令值1，运行时解码为true。


// 以下指令的附参即为值数据。

3       {}(1)       单字节存储：-uint8  [-255, 0]
4       {}(1)       单字节存储：uint8   [0, 255]
5       {}(2)       双字节存储：-uint16 [-0xffff, 0]
6       {}(2)       双字节存储：uint16  [0, 0xffff]
7       {}(4)       四字节存储：-uint32 [-0xffffffff, 0]
8       {}(4)       四字节存储：uint32  [0, 0xffffffff]
9       {}(8)       八字节存储：int64   [-1<<63, 1<<63 - 1]，即 Int
        // 类型：Int，整数。
        // 附参：指令的关联数据。
        // 从源码解析为指令时，数据值的大小自动决定使用哪个指令。
        // 例：
        // {12756}  入栈正整数，指令选用int16（指令值5）。
        //          脚本中指令序列：首字节值5，后2字节为值 12756
        // {0xfff0} 入栈正整数，指令选用uint16（指令值6）。
        //          脚本中指令序列：首字节值6，后2字节为值 0xfff0（65520）
        // 友好：
        // 支持单下划线分隔书写，如：{12_345} 实为整数 12345。

10      {}(1)       字节类型：byte
        // 类型：byte，字节。
        // 附参：关联的字符数据（单字节长）。
        // 格式：
        // {'A'} 单引号包围目标字符A。
        // - 支持常规转义表达，如 {'\n'}，一个换行符值（10）。
        // - 支持16进制转义表达，如 '\x41'，即字符 'A'（65）。

11      {}(4)       字符类型：rune
        // 类型：rune，字符。
        // 附参：关联的宽字符数据，UTF-8无法用单字节存储的字符。
        // 格式：
        // {'嗨'} 单引号包围的 Unicode 字符。
        // - 支持 '\uhhhh' 或 '\Uhhhhhhhh' 转义。
        // 如：
        // '\u4e16' => '世'，同 '\U00004e16'
        //
        // 说明：
        // 字符类型与 byte 类型采用相同的单引号包围格式，
        // 源码解析器会根据值的大小自动判断存储类型（byte 或 rune）。
        // 如果需要将256以内的值存为rune，需采用Unicode转义方式（前置\u或\U）。
        // 如：
        // '\u0041' 字符A存为rune，以便于[]rune类的操作。

12      {}(4)       四字节浮点数存储：float32
13      {}(8)       八字节浮点数存储：float64，即 Float
        // 类型：Float，浮点数。
        // 附参：指令的关联数据。
        // 源码书写时必须包含小数点，支持科学记数法。
        // 解析为指令时，值的大小自动决定使用哪个指令。
        // 例：
        // {3.14159} 入栈浮点数 3.14159。指令值为11。
        // {2.1606e108} 超出float32容量。指令值为12。
        // 注记：
        // 系统实现会统一转换到float64类型后使用。

14      TIME{}(~)   时间戳
        // 类型：Date。
        // 附参：UNIX时间戳。变长正整数。
        // 花括号内书写为标准格式的时间表达式（RFC3339）。
        // 例：
        // TIME{2020-11-24T15:04:05Z}
        // TIME{2020-11-24T15:04:05+08:00}
        // TIME{2020-11-24T15:04:05.456+08:00}
        // 注：
        // 格式串中秒数后面可附加毫秒，以句点连接。
        // 仅支持RFC3339，更多的格式可使用日期模块 MO_DATE。


// 以下指令的附参标明数据的长度（字节数）。

15      {}(1)+N     大整数，字节长度不定（<256）
        // 类型：BigInt。
        // 附参：实际数据占用的字节数。
        // 注：也即Go语言中 math/big 包里的Int类型。
        // 例：
        // {0x8000ffff_8000ffff_8001}
        // 超出了int64的表示范围，会被解析为大整数。
        // 注记：
        // 大数值通常用16进制书写，值内支持下划线友好分隔。

16      DATA{}(1)   字节序列数据。1字节附参
17      DATA{}(2)   字节序列数据。2字节附参
        // 类型：Bytes，字节序列。
        // 附参：实际数据的长度（字节数）。
        // 源码书写时使用16进制字符串，解析时值的长度自动决定指令值（若未指定附参）。
        // DATA{}(2) 指令2字节附参最大可表示64kb数据。
        // 例1：
        // DATA{46af3fb481837fadbb421727f9959c2d} 入栈16字节值，按16进制解析。
        // 解析后的指令序列：
        // [16|16|0x46|0xaf|0x3f|...]
        // 其中：指令值（16）1字节，附参值（16）1字节，后续16字节数据。
        // 例2:
        // DATA[8]{46af3fb4} 入栈8字节，后续不足者用0值填充。
        // 解析后的指令序列：
        // [16|8|0x46|0xaf|0x3f|0xb4|0|0|0|0] 指令值+附参值+数据共10字节。
        // 注：
        // 花括号内的16进制字符串无需前置 0x 标识。

18      TEXT{}(1)   文本数据。1字节附参
19      TEXT{}(2)   文本数据。2字节附参
        // 类型：String，字符串。
        // 附参：实际字符串 `UTF-8` 编码字节数。
        // 从源码解析为指令序列时，文本的字节长度自动决定使用哪个指令。
        // 例：
        // TEXT{Hello}      入栈 Hello 文本串。
        // TEXT{ Hello }    同上，首尾空格视为显示友好（非数据，可选）。
        // TEXT{"Hello "}   若需在首尾包含空白，需要使用双引号包围。
        // 注意：
        // 不必也不应当手工指定附参值大小。

20      /.../(1)    正则表达式
        // 类型：RegExp。
        // 附参：表达式占用字节数。
        // 双斜线之内即为正则表达式的内容（regexp/syntax RE2）。
        // 例：
        // /(?i)[a-z0-9]+/  匹配ASCII字母和数字，忽略大小写
        // /(?i)Zip-(\d+)/  忽略大小写，包含一个子匹配式（捕获组）

21      CODE{}(1)   代码/指令序列
        // 类型：Script。
        // 关联数据为一段解析后的指令序列（指令值+附参+数据）。
        // 附参：序列长度。
        // 例：
        // CODE{
        //      TOP FN_HASH256 DATA{<hashResult>} EQUAL PASS
        // }
        // 入栈一段哈希屏障验证的指令序列。
        // 附参无需书写，将由解析器解析后自动设置。换行只是一种友好。
        //
        // 注记：
        // - 这里仅支持<256长度的直接指令序列书写，如果需要更长的脚本，
        //   可用 DATA{}(2) 表达然后再转换（SCRIPT）。
        // - 数据中的指令名称仅在解析阶段有意义。
```


### 2. 取值指令

捕获指令的返回值，或者从某些地方提取值。该类指令无实参。

首先是截取后面跟随指令的返回值的两个指令 `@` 和 `$`。设置该指令后，后面紧跟指令的返回值不再自动入栈，而是放入实参空间（`@`）或者添加到当前的局部域中（`$`）。

其次是从 `$` 放入的局部域中取值的指令 `$(1)`，附参定义了取值位置，以及一个从循环域中获取当前循环状态值的指令 `${}(1)`。

最后还有一个特殊的实参直取（`~`）指令，表示后面紧跟的指令直接从数据栈取实参（跳过实参空间）。该指令对**无实参**和**不定参数**的指令无效，如果它在这种指令之前，会被简单忽略。另外，它与跟随指令的紧密度优于截取指令 `@` 和 `$`，因此如果必要，它会在这两个指令与其操作的指令之间，如 `@~EQUAL`：相等指令 `EQUAL` 直接从数据栈获取实参，比较结果被截取放到实参区。

这是几个用特殊符号表示的指令，功能独特。作为一种显示方便，符号与后面跟随的指令无需空格分隔。

指令值区间：`[22-26]`，5个。

```go
指令值  指令字      说明
-----------------------------------------------------------
22      @           实参捕获
        // 拦截后一个指令的返回值添加到实参区。
        // 因为实参空间是一个值队列，所以也可以形象地理解为放入当前位置。
        // 例1：
        //      {0} @PEEKS[2] @SPREAD PRINT[16]
        // 获取栈底2个值的切片放入实参区，展开该切片，向控制台打印它们。
        // 例2：
        //      @POPS[3] OUTPUT BUFDUMP
        // 弹出栈顶3项数据为一个切片，输出到缓存区并转储清空。
        // 注：
        // 如果@后面是实参直取指令~（见下），会简单跳过。

23      ~           实参直取
        // 指示后一个指令的实参将从数据栈直接提取（跳过实参空间）。
        // 这是一种主动的取值渠道切换。
        // 该指令通常与后面的指令紧邻，但空格是可选的。
        // 例：
        // ~EQUAL   直接取栈顶两个值比较相等与否，返回一个布尔值入栈。
        // @~EQUAL  同上取栈顶两个值比较，但结果被截取放入实参区。
        // $~EQUAL  同上比较，结果添加到当前局部域。
        // 注记：
        // 支持跳过实参空间取实参，可为数据的腾挪增加更多灵活性。

24      $           局域存值
        // 截取后一个指令的返回值添加到当前局部域中。
        // 局部域是一个静态堆叠空间（只添加），高度小于128（最多可添加128个值）。
        // 通过位置下标引用堆叠中成员。
        // 与实参创建指令@相同，如果后面是实参直取指令~，会简单忽略。
        // 例：
        // $TOP       引用栈顶项添加到当前局部域中（实为复制）。
        // $POPS[3]   弹出栈顶3项添加到局部域中（3个成员的切片）。
        // ${100}     将值 100 直接存入局部域。
        // @POPS[3] $SPREAD  弹出栈顶3项打包为一个切片，展开添加到局部域中。
        //
        // 注意：
        // 每一个语法块都会有一个当前局部域，即便只是一个简单的 IF{} 块。
        // 各个语法块的局部域是无法互访的，因此只有平级的指令才共享相同的局部域。
        // 如果需要跨级访问，请使用脚本域的全局变量空间（VAR/SETVAR）。
        //
        // 注记：
        // 这种仅平级指令才能共享的特性，为下面的局部域用名称取值提供了方便，
        // 使得可静态解析分析名称位置（无需运行时）。

25      $(1)        局域引用
        // 按添加时的顺序引用局部域的值。
        // 这可视为上面$的逆指令。
        // 作为取值指令，它引用的值会自动添加进实参区而非入栈。
        // 附参：局部域成员下标，int8 支持负数从末尾算起。
        // 例：
        // $[0]   引用第1个添加进局部域中的值。
        // $[-1]  引用最后一个添加到局部的值。
        // 友好：
        // 可以用$存值时所截取指令的名称来取值，名称用花括号包围。
        // 不过需要注意名称重复覆盖的问题，最好就近使用。
        // 例：
        // $POP   弹出栈顶项添加到当前局部域。
        // ${POP} 从局部域获取上面添加的值。
        // $MO_MATH.Abs   取栈顶值计算绝对值后，添加到当前局部域。
        // ${MO_MATH.Abs} 从局部域中获取上面添加的值。
        // 注：
        // 模块方法调用表示为用句点连接模块名和方法名。
        // 例：
        // $[0] $[1] $[2] PUSH
        // 将局部域前3个值压入到数据栈。
        //
        // 注记：
        // 友好名称引用在源码解析阶段有效，实际的脚本代码中附参依然只是一个数值。
        // 因为局部域并不能跨层级引用，所以解析阶段即可以准确定位（平级约束）。

26      ${}(1)      循环域变量引用
        // 仅用于循环体内，但可跨语法块层级（与上面的局域不同）。
        // 附参：成员引用位置。
        // 只支持4个成员：
        // - ${Value}   当前条目值 [0]
        // - ${Key}     当前循环键（整数下标或字符串） [1]
        // - ${Data}    目标集本身 [2]
        // - ${Size}    集合大小（迭代次数） [3]
        // 注意：
        // - 名称大小写敏感。这是与上面局域引用中采用指令名时的区别。
        //   也不能直接采用数字形式引用，这会与局域引用混淆。
        // - 与局域引用类似，作为取值指令，返回值进入实参空间而非入栈。
```

> #### 注：
> 除了局域存值（`$`）和实参直取（`~`）外，取值指令都是把得到的值放入实参空间（而不是消费）。


### 3. 栈操作指令

对脚本数据栈中的条目执行直接的操作，如：入栈、出栈、引用、转移等。通常会配合取值指令 `@` 或 `$` 使用。

指令值区间：`[27-36]`，10个。

```go
指令值  指令字      说明
-----------------------------------------------------------
27      NOP         无操作
        // 实参：不定数量。
        // 无任何操作，但会读取实参区，即清空。
        // 返回值：无。
        // 例：
        // @INPUT[] NOP 读取导入缓存区到实参区，然后清空。
        // @SHIFT[] NOP 同上原理，清空数据栈。
        // NOP          无任何行为，继续。
        // 注记：
        // 不定数量实参允许0个实参（系统不会自动从数据栈取值）。

28      PUSH        数据入栈
        // 把实参区全部内容按顺序压入数据栈。
        // 实参：不定数量。
        // 返回值：无。
        // 例：
        // @PEEK[0] @INPUT[] PUSH  提取栈底项和缓冲区全部数据，顺序压入数据栈。
        // ... PUSH  如果实参区为空，这是一个空操作。

29      SHIFT(1)    转移栈顶条目
        // 移出栈顶多个条目，保持原顺序展开到目标位置。
        // 附参：取栈条目数。uint8类型，0值表示全部。
        // 实参：无。
        // 如果条目数超出栈高度，执行会失败。
        // 返回值：多值自动展开。
        // 例：
        // @SHIFT[4]    移出栈顶4项原样添加到实参区。
        // $SHIFT[4]    同上但添加到当前局部域。
        // @SHIFT[]     移出数据栈全部条目到实参区。0可选。
        // @SHIFT[0]    同上。
        // SHIFT[4]     移出4项又原样返回入栈，没有意义。
        // @SHIFT[1]    移出栈顶1项到实参区，与 @POP 同。
        // 注意：
        // 转移会维持栈内数据的先后顺序，即先入栈的在前。
        // 通常前置取值指令，否则返回值会重新入栈（没有意义）。
        // 注：
        // 某种程度上可视为 PUSH 指令的逆操作。

30      CLONE(1)    克隆栈顶条目
        // 克隆栈顶多项数据，保持原始顺序展开到目标位置。
        // 附参：克隆数量。uint8类型，0值无意义。
        // 实参：无。
        // 返回值：多值自动展开。
        // 注意：此为浅克隆，切片或字典条目依然会引用源数据。
        // 例：
        // @CLONE[3]    克隆栈顶3项，展开添加到实参区。
        // $CLONE[3]    同上克隆展开添加到当前局部域。
        // CLONE[3]     克隆栈顶3项展开入栈。
        // CLONE[0]     无克隆项，没有意义。
        // 提示：
        // 与后面运算指令DUP的区别：
        // - DUP[n]     取出栈顶 1 项复制 n 次，返回 1+n 项展开。
        // - CLONE[n]   复制栈顶 n 项 1 次，返回 n 项展开。
        // 例：
        // DUP[1]       取出并复制1次，返回两项展开。栈顶有两个相同数据
        // CLONE[1]     引用复制1项，返回一项入栈。效果同上。
        // TOP          引用栈顶项返回，效果同上。


// 以下指令直接读取数据栈，无实参。
// 注：返回的切片不会自动展开。

31      POP         栈顶项弹出
        // 返回值：栈顶项。
        // 如果没有前置取值指令，返回值会自动重新入栈（无意义）。
        // 例：
        // @POP     弹出栈顶项添加到实参区。
        // $POP     弹出栈顶项添加到当前局部域存储。
        // POP      弹出栈顶项又返回入栈，没有意义。

32      POPS(1)     栈顶多项弹出
        // 附参：弹出的条目数。
        // 附参为uint8类型，0值表示弹出全部。
        // 如果条目数超出栈高度，执行会失败。
        // 返回值：一个Any切片
        // 弹出的集合维持栈内数据原有的顺序（先进者在前）。
        // 例：
        // POPS[4]  打包栈顶4项为一个切片。
        // @POPS[4] 弹出栈顶4项打包为一个切片添加到实参区。
        // @POPS[]  同上打包添加但取出栈内全部条目。@POPS[0] 同。

33      TOP         引用栈顶项
        // 返回值：栈顶项。
        // 如果没有前置取值指令，返回值会自动重新入栈。
        // 例：
        // @TOP 引用栈顶项添加到实参区。
        // TOP  引用栈顶项并返回入栈，相当于克隆/复制1项。

34      TOPS(1)     引用栈顶多个条目
        // 附参：引用条目数。
        // 附参uint8类型，0值无引用（与POPS不同）。
        // 如果条目数超出栈高度，执行会失败。
        // 返回值：一个Any切片。
        // 同POPS，成员维持栈内原有底顶顺序。
        // 例：
        // TOPS[1] 引用栈顶项封装为一个单成员切片返回。
        // TOPS[3] 引用栈顶3项封装为一个切片返回。
        // TOPS[]  无引用返回一个空切片。


// 以下指令由实参指定下标位置。

35      PEEK        引用栈内任意位置条目
        // 实参：目标条目下标。
        // 栈底位置为0，支持负数从栈顶算起。
        // 返回值：引用目标项。
        // 例：
        // {-1} PEEK    与 TOP 效果相同。
        // {0} PEEK     引用栈底项入栈（克隆栈底项到栈顶）。
        // {0} @PEEK[]  同上引用，添加到实参区。
        // {0} $PEEK[]  同上引用，放入当前局部域。

36      PEEKS(1)    引用栈内任意位置段条目
        // 附参：引用条目数。
        // uint8类型，最多引用255条。0值表示目标位置之后全部。
        // 实参：起始位置下标。
        // 栈底位置为0，支持负值从栈顶算起（当前实参不计在内）。
        // 如果位置下标超出栈高度，或实际数量不足，执行会失败。
        // 返回值：目标位置段条目的Any切片。
        // 例：
        // {0} @PEEKS[5]    引用栈底5项数据封装放入实参区。
        // {-5} @PEEKS[0]   引用栈顶5项封装放入实参区，同：@TOPS[5]
        // {0} PEEKS[5]     引用栈底5项封装返回入栈。
```


### 4. 集合类指令

支持可迭代集合（通常是一个切片/数组）的一些基本操作。

指令值区间：`[37-47]`，11个。

```go
指令值  指令字      说明
-----------------------------------------------------------
37      SLICE(1)    局部切片
        // 对切片类目标切分出一个子切片。
        // 附参：子切片的大小。uint8类型，0值表示目标位置之后全部。
        // 实参1：目标集合。
        // 实参2：起始下标，支持负数从末尾算起。
        // 返回值：一个同类切片。
        // 例：
        //      {0} RANGE[10]       //=> [0,1,2,3,4,5,6,7,8,9]
        //      @POP @{5} SILCE[3]  //=> [5,6,7]
        //      或：
        //      {5} SLICE[3]        // 不取出，结果同上。
        // 注意：
        // - 如果目标位置之后成员不足，执行失败。
        // - 如果起始下标超出集合大小，执行失败。
        // - 如果起始下标等于目标集大小且附参为0，返回一个空切片。
        // 支持：
        // Bytes    切分出一个 []byte 序列。
        // Runes    切分出一个子 []rune 切片。
        // []any    依然切分出一个 []any 类型。
        // []Int    切分出一个同类子片。
        // []Float  同上切分出一个同类子片。
        // 注：
        // Script 类型不支持该指令，虽然它的底层是 []byte 类型。
        // 如果需要处理字符串，可能应该使用SUBSTR指令，或者转换为Runes后再切分。

38      REVERSE     序列反转
        // 将切片内的成员顺序反转。
        // 实参：目标集合。
        // 返回值：一个新切片。
        // 支持：Bytes, []rune, []any 类型数据。

39      MERGE       分片合并
        // 将多个切片合并为一个切片。
        // 实参：1+不定数量。首个实参必须存在。
        // 返回值：一个新切片。
        // 例：
        // @SHIFT[3] MERGE  栈顶3项添加到实参区，合并为一。
        // 注意：
        // DATA{}值并不是一个[]byte切片，而是一个Bytes单值。

40      EXPAND      切片扩充
        // 将实参成员添加进目标集合。
        // 实参：1+不定数量。首个实参为目标集，后续为待添加成员。
        // 返回： 扩充后的一个切片。

41      GLUE        序列成员粘合
        // 将切片的成员串连在一起。
        // 各个成员之间紧邻，并没有分隔彼此的分隔符。
        // 实参：一个切片。
        // 返回值：一个字节序列。
        // 例：
        // POPS[3] GLUE 将栈顶3项数据打包后串连在一起。
        // 注：
        // 仅适用于 byte、rune、Bytes 和 String 类型的成员。
        // 各个成员可以是这三种类型的任意一种（混杂合法）。

42      SPREAD      序列展开
        // 将目标切片展开返回。
        // 如果前置取值指令，会展开添加到目标空间。
        // 实参：一个切片。
        // 返回值：不定数量。
        // 例：
        // $SPREAD  取栈顶项展开压入当前局部域。
        // @SPREAD  取栈顶项展开添加到实参区。
        // ~SPREAD  将栈顶项展开后返回入栈（POPS逆操作）。
        // 注意：
        // 栈顶项需要是可展开类型，比如一个切片条目。
        // 提示：
        // 连续的 @~SPREAD 可将栈内多个切片逐一展开到实参区。

43      ITEM        成员条目获取
        // 获取数据集合中的单个成员。
        // 实参1：目标集，切片或字典（map[string]any）。
        // 实参2：成员位置下标或键名，数值下标支持负数从末尾算起。
        // 返回值：目标成员值，单值。
        // 例：
        //      POPS[5] PEEK[0] ITEM EQUAL PASS
        // - 取栈顶5项打包为一个集合入栈。
        // - 取栈底成员值（可能由解锁实参传入）入栈。
        // - 获取集合内目标位置的值入栈。
        // - 比较此时的栈顶2项是否相等（5个成员已弹出，最新入栈为拣取值）。
        // - 相等则验证通过。
        // 注意：
        // 从字典中取值时，如果条目不存在会取到一个默认零值。

44      SIZE        集合大小
        // 实参：一个切片或字典。
        // 返回值：一个整数。

45      （保留未用）


// 下两个指令含子语法块：
// 包含一个私有数据栈，实参用于初始化该数据栈。

46      MAP{}(1)    映射迭代
        // 针对目标集，迭代每一个成员执行子语句块，返回值构造为一个最终切片。
        // 附参：子语句块长度。
        // 实参：1+不定数量。首个成员为目标集，后续为私有数据栈初始成员。
        // 返回值：一个切片。
        // 语法：
        // 子语句块拥有一个局部私有环境（数据栈、实参区），与上层脚本无关。
        // 私有环境在各个迭代之间是共享的（注意实参区也是共享的）。
        // 局部变量：
        // - ${Value}   // 当前条目数据
        // - ${Key}     // 当前循环键（整数下标或字符串）
        // - ${Data}    // 迭代集本身
        // - ${Size}    // 集合大小（迭代次数）
        // 注意：
        // 子语法内返回的 nil 值会被忽略，这让指令也有筛选的能力。
        // 目标集通常是一个切片，但兼容字典，如果是后者，迭代的顺序是不确定的。
        // 例：
        // {10} RANGE[3]    // 创建了一个切片 [10,11,12] 入栈
        // {200} {300}      // 简单入栈2个值
        // @SHIFT[3]        // 首个实参为待迭代集合，后续实参将进入MAP的私有栈
        // MAP{
        //      ${Key} @POP PRINT
        //      ${Key} ${Value} PRINT
        //      @( ${Value} * 2 ) RETURN
        // }
        // 将打印共3组值：
        // - 0 300      // 第1次
        // - 0 10
        // - 1 200      // 第2次
        // - 1 11
        // - 2 <nil>    // 第3次，栈内已无值
        // - 2 12
        // 返回的结果集：[20, 22, 24] 自动进入上层数据栈。

47      FILTER{}(1)   成员过滤
        // 针对目标集，迭代每一个成员执行子语句块，提取返回真值的源成员。
        // 附参：子语句块长度。
        // 实参：1+不定数量。首个成员为目标集，后续为私有数据栈初始成员。
        // 返回值：一个切片或字典。
        // 语法和局部变量参考上面MAP指令。
        // 支持字典的过滤，返回假值的循环其条目会被丢弃。
        // 返回值维持原类型。注意字典的迭代顺序是不确定的。
        // 例：
        // {10} RANGE[4]        // 创建了一个切片 [10,11,12,13] 入栈
        // @POP                 // 仅有一个实参（目标集）
        // FILTER{              // 私有栈为空
        //      ( ${Key} % 2 )
        //      @BOOL RETURN
        // }
        // 返回的结果：奇数集 [11, 13]，进入上层数据栈（整体返回值）。
        // 注：
        // 依然可以前置取值指令截取返回值：@FILTER{...}
```

> #### 关于Each
> `EACH{}` 指令是作为流程控制而非集合指令对待，一是因为它无需返回值，二是它内部应支持 `BREAK` 指令。<br>
> 另外，因为只是流程控制指令，所以 `EACH{}` 也没有子语句块的私有栈逻辑。<br>


### 5. 交互指令

在脚本的执行中存在一个数据的「缓存区」结构，它是与外部世界发生联系的一个中介区域。

缓存区是一个先进先出（FIFO）的队列结构，读取即为移出。导入和导出是两个各自独立的区域。对缓存区的写入（导出）和转出是非阻塞的，从缓存区导入则会视情况而定：有数据时正常执行，无数据时终止脚本（`EXIT`）。

指令值区间：`[48-53]`，6个。

```go
指令值  指令字      说明
-----------------------------------------------------------
48      INPUT(1)    导入缓存区数据
        // 如果无值或数量不足，执行会失败（验证不通过）。
        // 这是一种严格逻辑，因此通常不会用在可支付脚本中，
        // 更多的使用场景可能是在识别脚本中，数据由客户端自己提供。
        // 附参：读取的条目数，0值表示全部。
        // 实参：无。
        // 返回值：不定数量自动展开到目标空间。
        // 例：
        // @INPUT[0]    导入缓存区全部数据展开到实参区。
        // $INPUT[3]    导入缓存区头部3项数据展开添加到当前局部域。
        // INPUT[3]     导入缓存取头部3项数据展开入栈。
        // @INPUT[] NOP 导入缓存区全部数据到实参区，然后清空。
        //
        // 注记：
        // 缓存区是一个队列（FIFO）结构，脚本顺序与导入顺序一致会更友好。

49      OUTPUT      导出数据到缓存区
        // 实参：不定数量。
        // 因为实参为不定数量，所以仅会导出实参区内容。
        // 与INPUT和SHIFT指令类似，有自动展开能力。
        // 例：
        // @SHIFT[] OUTPUT  移出数据栈全部内容到缓存区（原样保持）。
        // ... OUTPUT  若实参区为空，无任何效果。
        //
        // 注记：
        // 导出缓存区没有大小限制，但间接受制于实参空间大小。

50      BUFDUMP(1)  导出缓存区数据转出
        // 将导出缓存区内容转出到外部（清空缓存区）。
        // 附参：序位标识，uint8。
        // 实参：无。
        // 第三方服务可预先注册处理器，接收转出的数据并完成自己的逻辑。
        // 这是一个无阻塞操作，可触发外部响应机制。
        // 序位标识实际上可为任意值（<256），在同一段脚本中唯一即可，
        // 主要用于接收者定位数据转出点（位置）。
        // 注：
        // 有无第三方是一种私有逻辑，只有需要的节点才需要执行。

51-52   （保留未用）

53      PRINT       控制台打印
        // 将实参区的内容打印到标准控制台。
        // 实参：不定数量。
        // 实际上就是调用 fmt.Println()，采用默认的格式打印。
        // 多个实参条目间会以一个空格分隔。
        // 例：
        // @TOP PRINT  打印栈顶项数据。
        // @SHIFT[3] PRINT  打印栈顶3项数据。
```


### 6. 结果指令

对脚本的执行实施检查和控制（通关），如：通过、失败、退出或跳转等。如果脚本执行中未碰上失败，就视为验证通过。

通常来说，锁定脚本中必然存在通关性指令 `PASS` 或 `FAIL`，不然就没有锁定的逻辑（任何人皆可“解锁”脚本）。

指令值区间：`[54-59]`，6个。

```go
指令值  指令字      说明
----------------------------------------------------------
54      PASS        检查通过（安检）
        // 实参值为true时通过，否则失败。
        // 失败会导致脚本结束，信用转移失败（即验证失败）。
        // 实参：布尔值。
        // 返回值：无。
        // 注记：
        // 通关失败可能触发某种通知机制，以便外部可以了解情况。
        // 如果外部需要监控验证，这是很有必要的。

55      FAIL        验证失败
        // 实参值为true时失败。
        // 这是 NOT PASS 的简捷版，但表意更清晰。
        // 实参：布尔值。
        // 返回值：无。

56      GOTO(4,4,2)  执行流跳转（独立）
        // 跳转到目标区块的某个交易输出脚本。
        // - 实参区数据传递到新脚本作为数据栈初始内容。
        // - 新脚本延续当前的校验，但有其自身的环境（数据栈、实参区、全局变量区），
        //   但共享导入/导出缓存区。
        // - 新脚本的验证结果即为当前脚本的结果。
        // 附参1：区块高度，uint32类型
        // 附参2：交易ID在区块中的序位，uint32类型
        // 附参3：输出项索引，uint16类型。
        // 实参：不定数量。
        // 返回值：无。
        // 例：
        //      @SHIFT[10] GOTO[1000, 355, 1]
        // 提取栈顶10项数据，跳转到第1000号理想块的第356位交易的第2项输出，传递实参为其数据栈初始内容。
        //
        // 安全性：
        // 考虑安全性和性能，系统的实现中对连续跳转会有一些限制。
        // - 循环块（MAP, FILTER, EACH）内不允许跳转。
        // - EVAL 所执行的代码内禁止跳转。
        // - 一段脚本中运行时的跳转积累不能超过3次。

57      JUMP(4,4,2)  执行流跳转（嵌入）
        // 跳转定位与 GOTO 指令相同。
        // 目标脚本为嵌入逻辑，共享当前的脚本环境（数据栈、实参区、全局变量区等）。
        // 子脚本有自己的顶层局部域。
        // 附参：（同上GOTO）
        // 实参：无。
        // 返回值：无。
        // 例：
        //      JUMP[1000, 355, 1] FN_HASH256 DATA{...} EQUAL PASS
        // 跳转执行嵌入代码。
        // 返回后取栈顶值计算哈希摘要（FN_HASH256）和后面的工作。
        // 注：
        // 目标子脚本可能已往当前栈中添加了哈希源数据。
        //
        // 安全性：
        // 与 GOTO 类似，脚本中允许使用的JUMP指令有一个限度。
        // - 私有域的循环（MAP, FILTER）内禁止嵌入，但 EACH 内允许。
        // - EVAL 的外部代码内禁止嵌入。
        // - 一段脚本中运行时的嵌入积累不能超过9次。

58      EXIT        脚本结束
        // 结束脚本的执行。至此无错视为验证通过。
        // 如果实参区有值，返回该值（到系统，可能会被处理）。
        // 实参：不定数量。
        // 返回值：
        // 即实参值，任意类型。多个值会被打包为一个切片。

59      RETURN      返回一个值
        // 从子语句块退出并返回一个值。
        // 只适用于函数式语句块 MAP{} 和 FILTER{}，退出当前迭代。
        // 实参：任意类型，单值。
        // 返回值：即实参值。
        // 例：
        //      MAP{
        //           ... @POP RETURN  // 每次返回弹出的栈顶项。注：无 @POP 也同
        //      }                     // 全部迭代的返回值构成一个切片，作为MAP的返回值
        //      @SPREAD               // 该MAP的返回值被展开添加到实参区。
        // 注意：
        // 无返回值时应当返回nil，此时 NIL 指令就有用了。
```


### 7. 流程指令

普通编程语言中是以花括号限定语句块的范围，通过词法解析来编译和执行代码。栈脚本是指令值序列，需要实时解析并对阅读友好，为了提高效率，语句块的长度被作为附参附在了指令之后。

同时，附参的字节长度也限定了语句块的长度范围，这是一种严格约束，可以一定程度限制脚本结构的复杂性。

语句块的最终长度由解析器解析计算而来，书写时无需包含中括号的附参明示（那会很麻烦）。指令的子语句块即为该指令的关联数据。

指令值区间：`[60-67]`，8个。

```go
指令值  指令字      说明
-----------------------------------------------------------
60      IF{}(1)     真值执行
        // 附参：子语句块长度，uint8类型。
        // 实参：布尔值。
        // 实参值为true时执行子语句块。
        // 注记：
        // 会设置IF的状态，供后续可能的ELSE指令判断。
        // 例：
        //      ... EQUAL   // 比较结果入栈。
        //      IF{         // 栈顶值为true时执行子语句块
        //           TRUE PRINT  // 打印 true
        //      }
        // 说明：
        // - IF的条件由它的实参表达，在指令之前就已经计算好了。
        //   这是栈脚本栈式结构的特点。
        // - IF和ELSE并不需要紧邻，两者之间可以有其它普通语句。
        //   IF状态在同层级是共享的，后来的IF会覆盖之前的IF状态（影响ELSE逻辑）。

61      ELSE{}(1)   IF不满足时执行
        // 检查本层级IF状态值，如果IF为假则执行本语句块。
        // 附参：指令块长度，uint8类型。
        // 实参：无。
        // 注：
        // 连续的ELSE是可能的，它们相对于前面的IF状态判断自身的逻辑。
        // 虽然这看起来有点怪异。
        // 如果ELSE块很大，这可以是一种拆分策略。

62      SWITCH{}(2) 分支选择区
        // switch 语法块开启。
        // 附参：区块长度，uint16类型。
        // 实参1：标的值。将与CASE分支值对比，任意可比较类型。
        // 实参2：CASE分支值列表，长度与CASE数量相同。
        // 提示：
        // 若标的值为true，可模拟 if/elseif/else 的逻辑。

63      CASE{}(1)   条件分支
        // 附参：语句块长度。
        // 实参：无。已由SWITCH指令预先取出，按位置逐项对比。
        // 相应值对比结果：
        // - 真：执行子语句块。
        // - 假：跳过子语句块。
        // 说明：
        // CASE 块如果被执行，之后即结束 SWITCH 语法块。
        // CASE 块中也可以用 BREAK 指令提前退出。
        // 例：
        // @POP                 // SWITCH 标的值
        // @POPS[3]             // CASE 分支对比值序列
        // SWITCH{
        //      CASE{           // 序列[0]与SWITCH标的值比较，相等则执行
        //          ...
        //          BREAK       // 可选，会自然退出
        //      }
        //      CASE{           // 序列[1]与标的值比较...
        //          ...
        //      }
        //      CASE{           // 序列[2]与标的值比较...
        //          ...
        //      }
        //      DEFAULT{...}    // 默认分支，无CASE匹配时至此，无条件执行
        // }
        // 注记：
        // CASE分支的值在执行SWITCH时已全部取出，这样可避免数据栈内残留CASE值的麻烦。
        // 同时，SWITCH也应当与其子CASE视为一体。
        // 平级CASE之间实际上可以插入普通指令，但这可能并不是一种最佳实践。

64      DEFAULT{}(1)  默认分支
        // 无条件执行。
        // 附参：语句块长度。
        // 实参：无。
        // 说明：
        // 其它CASE分支未执行时执行，只能在所有CASE之后。可选。

65      EACH{}(1)   迭代式循环
        // 对集合成员逐一迭代处理。
        // 附参：循环块长度。
        // 实参：可迭代集合（切片或字典）。
        // 局部变量：
        // - ${Value}   // 当前条目数据
        // - ${Key}     // 当前循环下标，从0开始
        // - ${Data}    // 目标集合本身
        // - ${Size}    // 迭代条目总数
        //
        // 与集合类指令MAP/FILTER不同，这里全局数据栈是可见的。
        // 另外，如果需要中断当前循环，需要执行 BREAK 而不是 RETURN。
        // 注：
        // EACH{} 指令是有限循环逻辑，没有返回值。
        // 注意：
        // 如果目标集是一个字典，迭代顺序是不确定的。

66      CONTINUE    跳入下一迭代
        // 会立即终止当前循环，开始下一次迭代。仅用于 EACH{} 指令内。
        // 实参：布尔值，可选。
        // 如果实参有值，则真值执行，假值略过。否则直接执行。
        // 类似上面的 BREAK 自带判断逻辑。

67      BREAK       退出EACH或SWITCH
        // 实参：布尔值，可选。
        // 如果实参有值，则真值执行，假值略过。否则直接执行。
        // 自带判断逻辑，可省略简单的IF{}结构。
        // 例：
        // @POPS[10]        // 取栈顶10项打包待处理
        // EACH{
        //      ${Value} @{1000}  // 当前值和目标值
        //      GT                // 当前值是否大于1000，结果入栈
        //      @POP BREAK        // 取比较结果，真值结束EACH{}，假值忽略
        // }
        // 注：EACH开始后实参区已为空。
```


### 8. 转换指令

运算是类型严格的，将脚本中的数据转换为不同的表达方式，有时是很需要的。

这里的转换不只是数据**类型**的转换，还包括值的改变。比如字符串 `"123"` 可以转换为整数 `123`，外观上虽然一致，但表达它们的二进制值实际上已经不一样了。而整数转换为字符串时，不是仅仅改变值的含义，如 `String(65)` 并不是将65视为码点值（`"A"`），而是转换为整数的字符串表示 `"65"`（如果设置为十进制的化）。

指令值区间：`[68-80]`，13个。

```go
指令值  指令字      说明
-----------------------------------------------------------
68      BOOL        转换为布尔值：Bool
        // 实参：
        // - 空值：     nil => false
        // - 字符串：   ""  => false
        // - 整数：     0   => false
        // - 字节：     0   => false
        // - 字符：     0   => false
        // - 大整数：   0   => false
        // - 浮点数：   x <= math.SmallestNonzeroFloat64 => false
        // 提示：
        // 测试字典或切片是否非空，可用 "SIZE BOOL"。

69      BYTE        转为字节：Byte
        // 作为 Bytes 的子成员而存在。
        // 实参：
        // - 整数：     小于256的值类型转换，否则出错
        // - 字符：     Unicode码值小于256的类型转换，否则出错
        // - 浮点数：   取整，小于256的值类型转换，否则出错。
        // - 空值：     nil => 0
        //
        // 注记：
        // uint8的别名，但拥有自己的逻辑（不同于Int）。
        // 转换到字符串时与Int不同，仅做单纯的类型转换（同Go）。

70      RUNE        转为字符：Rune
        // 作为字符序列 Runes 的子成员而存在。
        // 实参：
        // - 字节：     直接类型转换
        // - 整数：     小于int32最大值时类型转换，否则出错
        // - 浮点数：   先取整，同上整数转换规则。
        // - 空值：     nil => 0
        // - 字节序列： 按UTF-8编码解释，仅支持单个字符。
        // - 字符串：   （不支持）
        //
        // 注记：
        // int32的别名，但拥有自己的逻辑（不同于Int）。
        // 转换到字符串时与Int不同，仅按值含义做类型转换（会有UTF-8编码）。

71      INT         转换为整数：Int
        // 实参：
        // - 空值：     nil => 0
        // - 布尔值：   true => 1, false => 0
        // - 字节：     直接转换 byte()
        // - 字符：     直接转换 rune()
        // - 字符串：   Golang合法的整数表示：
        //              普通十进制
        //              0b|0B 二进制
        //              0o|0O 八进制
        //              0x|0X 十六进制
        //              数字之间支持单下划线友好分隔。
        // - 浮点数：   截断小数部分，超过int64上限的大数会抛出异常。
        // - 大整数：   值在int64的范围内则转换，否则抛出异常。
        // - 字节序列： 按大端序解释，长度需等于 1、2、4、8 的固定值。
        //
        // 注意：
        // 与字符串的相互转换按字面意义解释（strconv规则）。

72      BIGINT      转换为大整数：BigInt
        // 实参：
        // - 字符串：   合法的整数字符串表示，支持前缀标志。
        // - 字节序列： 按大端序转换（math/big）。
        // - 布尔值：   true => 1, false => 0
        // - 整数：     简单转换，无要求。
        // - 浮点数：   截断小数部分。
        // - 字节：     按整数简单转换。
        // - 字符：     按整数简单转换。
        // - 空值：     nil => BigInt(0)

73      FLOAT       转换为浮点数：Float
        // 实参：
        // - 布尔值：   true => 1.0; false => 0.0
        // - 整数：     简单的类型转换，无要求
        // - 字节：     按整数转换。
        // - 字符：     按整数转换。
        // - 字符串：   合法的浮点数或科学记数法表示。
        // - 空值：     nil => 0.0

74      STRING(1)   转换为字符串：String
        // 附参：进制或格式标识，仅适用数值类型。
        // - 2 ~ 36 整数进制。结果无前置标识（如 0x）。
        //          用法：如 STRING[16]，中括号指定具体的数值。
        // - 2 ~ 62 大整数进制，a-z 表示 10-35，A-Z表示 36-61。
        //          用法：同上整数方式，如 STRING[16]。
        // - b, e, E, f, g, G, x, X 浮点数格式标识。
        //          用法：如 STRING{E}，花括号包围标识字符，或中括号指定字符的值。
        // 实参：
        // - 布尔值：   true => "true"; false => "false"
        // - 整数：     按进制格式显示（strconv）。
        // - 大整数：   同上。
        // - 浮点数：   按格式标识显示（最少位数）。
        // - 字节：     视为字符值转换。
        // - 字符：     视为Unicode码点值转换。
        // - 字节序列： 视为UTF-8编码的字节序列。
        // - 字符序列： []rune => string(x) 自动UTF-8编码。
        // - 空值：     nil => ""

75      BYTES       转换为字节序列：Bytes
        // 实参：
        // - 空值：     nil => Bytes{} 零长度
        // - 整数：     按大端序转换，固定为8字节长。
        // - 大整数：   按大端序转换，长度不定。
        // - 字节：     长度为1的字节序列。
        // - 字符：     按字符的UTF-8编码转换。
        // - 字符串：   转换为字符串的UTF-8码值序列。
        // - 字符序列： 转为UTF-8编码的字节序列。
        // - 脚本：     类型简单转换。

76      RUNES       转换为字符序列：Runes
        // 转为单个字符的切片可方便某些处理。
        // 实参：
        // - 空值：     生成一个空 []rune
        // - 字符：     包含一个字符的字符切片。
        // - 字符串：   视为UTF-8编码解码为 []rune
        // - 字节序列： 同上解码，无效的UTF-8会解码为值 \uFFFD

77      DATE        转换为日期类型：Date
        // 用实参构造日期/时间值（毫秒数时间戳）。
        // 实参：
        // - 整数：     视为UNIX时间戳（毫秒数）。
        // - 字符串：   RFC3339的标准时间格式串。
        // 例：
        //      {1608883593536} DATE
        // 整数直接视为一个时间戳值（2020-12-25T08:06:33.536Z）。
        //
        //      TEXT{2020-12-25T08:06:33.536+08:00} DATE
        // 用RFC3339格式字符串构造一个时间值（上海时区，精确到毫秒）。
        // 毫秒数时间戳实为：1608854793536，比上面少8个小时。

78      SCRIPT      转为脚本指令序列：Script
        // 实参：
        // - 字节序列： 简单转换。

79      REGEXP      构造为一个正则表达式：RegExp
        // 用实参值构造一个正则表达式对象。
        // 实参：
        // - 字符串：   正则表达式的字符串形式。

80      DICT        构造为一个字典：Dict（map[string]any）
        // 实参1：键序列（[]string）
        // 实参2：值序列（[]any）
        // 两个实参序列的成员按顺序对应创建一个字典。
        // 键序列的大小可以多于值序列，无值对应的条目其值为 nil。
        // 如果值序列的大小多于键序列，会抛出错误（严格）。
        // 键仅支持字符串类型。
        // 例：
        //      TEXT{one} TEXT{two} TEXT{three} POPS[3]
        //      {100} {200} POPS[2]
        //      DICT
        // 创建为：{
        //      "one": 100,
        //      "two": 200,
        //      "three": <nil>,
        // }
        // 注记：
        // 切片其实也可视为一个字典，只是键名为连续的整数且只能从零开始。
```


### 9. 运算指令

有两种形式的运算指令：

1. 符号指令。操作数在符号两侧的常见形式，如：`{100} + {10}`。仅用于表达式内。
2. 命名指令。类似于函数的普通指令，操作数作为实参在指令之前，如：`{100} {10} ADD`。可用于表达式之外（结果自动入栈）。

指令值区间：`[81-105]`，25个。


#### 表达式

表达式是一个独立的运算单元，外部实参区和局部域对表达式内的指令是只读的。表达式中的指令可以正常获取实参，但其返回值只是一个操作数，而不会自动进入数据栈。

通常，表达式内只是一些值指令或简单取值类的指令，如 `{123}、POP、ENV、VAR、$[]` 等，但依然可以是复杂的函数类指令，它们从实参区或数据栈内取实参，运算的结果滞留于当前位置作为操作数，但这种编码方式并不友好。更好的方式是先执行这些复杂指令，让它们的结果进入数据栈或存入局部域，然后再在表达式中简单地获取它们。

表达式计算的最终结果会作为表达式指令本身的结果返回（并自动入栈），但这不包含内部的子表达式。

> **注：**
> 截取指令 `@` 和 `$` 在表达式内没有意义，但从局部域取值的 `${}` 依然可用，不过其自动添加到实参区的能力没有了。


#### 指令清单

```go
指令值  指令字      说明
-----------------------------------------------------------
81      ()(1)       表达式封装（根）
        // 内部可以包含子表达式，由下面的子表达式指令封装。
        // 内部的计算相对独立，可以从实参区和局部域取值但赋值（@, $）非法。
        // 附参：表达式长度。
        // 实参：无。
        // 返回值：任意类型，单值。
        // 例：
        // ( POP + {100} )  栈顶值加100，结果值返回自动入栈。
        // ( POP + ${100} ) 错误。无法添加局部变量（且 ${100} 也无返回值）
        // ( POP + $[0] )   正常。$[0] 为取值而非赋值
        //
        // 提示：
        // 顶层的根表达式与普通指令一样，返回值会自动入栈，
        // 因此它前面也同样可以使用取值指令（@, $）拦截结果。
        // 如：
        // $( POP + {100} )  将运算结果放入局部域

82      ()(1)       子表达式&优先级分组
        // 仅存在于根表达式之内，如 ( ...() ) 内部的括号。
        // 附参：子表达式长度。
        // 实参：无。
        // 返回值：任意类型，表达式内部使用。
        // 例：
        //      ( {1.5} * (POP + {100}) )
        // 内部的子表达式的结果只是一个操作数（留在原地）。


// 符号指令：
// 双操作数。仅用于表达式内部。
83      *           乘
84      +           加
85      -           减，或取负
86      %           模（正负号跟随左操作数，同Golang）
87      /           除

88      <<          左移位
89      >>          右移位
90      &           位与：AND
91      |           位或：OR
92      ^           位异或（XOR）
93      &^          位清空（AND NOT）
        // 实参在指令前后两侧。
        // 例：
        //      ( {100} + POP * {1.5} / {2} )
        // 注意运算符优先级。
        // 运算符之间的空格是可选的。


// 命名指令：
// 双实参。可用于表达式内外。
94      MUL         乘：MUL(x, y) => x*y
95      ADD         加：ADD(x, y) => x+y
96      SUB         减：SUB(x, y) => x-y
97      MOD         模：MOD(x, y) => x%y
98      DIV         除：DIV(x, y) => x/y
        // 实参1：支持目标操作的类型。
        // 实参2：同上。
        // 返回值：相应类型，单值。
        // 例：
        // {32} {100} MUL    入栈32和100，取栈顶2项相乘
        // @POP @{100} MUL   先取出到实参区后计算。
        // @POP {100} MUL    错误。实参区只有1个值（参数不足）。
        //
        // 例：
        //      ( {100} + MUL )
        // 表达式内 MUL 从外部实参区或数据栈取实参，但这里不直观。


// 命名指令：
// 单实参。可用于表达式内外。
99      NEG         取负：-x  // Int, Float
100     NOT         取反：!v  // Bool
        // 实参：目标操作数。
        // 例：
        // {0} PEEK NEG     取栈底项值，返回其负数
        // {123} BOOL NOT   结果为 false


// 命名指令：
// 多返回值，仅用于表达式外。
101     DIVMOD      除并求余
        // 实参1：支持该操作的类型。
        // 实参2：同上。
        // 返回值：商和余数，2个值。
        // 值1：x / y
        // 值2：x % y
        // 返回值自动展开到接收域。

102     DUP(1)      复制
        // 复制目标数据，返回值自动展开到接收域。
        // 附参：复制的份数，uint8类型。
        // 实参：目标项数据。
        // 返回值：原值+复制的条目，不定数量。
        // 例：
        // DUP[1]       取出栈顶项复制1份，与原值同时返回（共2份）。效果同 TOP。
        // DUP[2]       取出栈顶项复制2份，与原值同时返回（共3份）。
        // DUP[0]       没有复制，返回原值（实际上没做啥）。
        // $[0] @DUP[1] 引用局部域首个成员，复制后返回2份自动展开到实参区。
        // 注：
        // 适用任意数据类型，但仅为浅复制，主要用于Bytes和String。

103     DEL         删除
        // 删除字典（map[string]any）内的某个条目。
        // 实参1：目标字典。
        // 实参2：键名（字符串）。
        // 返回值：无。

104     CLEAR       清空
        // 将字典或切片的值清零，保留引用。
        // - 字典：内容全部移除。
        // - 切片：重置为零值，长度不变。
        // 实参：目标字典或切片。
        // 返回值：原目标。

105     SET         设置
        // 设置字典（map[string]any）某键的值。
        // 设置切片某下标位置的值。
        // 实参1：目标字典或切片。
        // 实参2：键名（字符串）或位置下标。
        // 实参3：目标值。
        // 返回值：原目标。
```

> #### 说明：
> `+` 指令支持字符串（`String`）的连接操作。<br>
> `ADD` 指令支持字符串（`String`）、字节序列（`Bytes`）和字典（`Dict`）的合并操作。<br>


### 10. 比较指令

两个或多个操作数执行比较，返回一个布尔值（单值）。

指令值区间：`[106-112]`，7个。

```go
指令值  指令字      说明
-----------------------------------------------------------
106     EQUAL       相等（a == b）
107     NEQUAL      不相等（a != b）
108     LT          小于（a < b）
109     LTE         小于等于（a <= b）
110     GT          大于（a > b）
111     GTE         大于等于（a >= b）
        // 实参1：支持该比较的类型。
        // 实参2：同上。
        // 返回值：true 或 false。

112     WITHIN      范围判断
        // 实参1：下边界值（包含）。
        // 实参2：上边界值（不包含）。
        // 实参3：待比较值。
        // 例：
        //      @{0} @{240} ENV{Height} WITHIN
        // 判断当前交易所在理想块高度是否为在第一天之内。
```

**注：**
> 序列（`Bytes`）类型的大小比较按从左到右的逐字节进行。布尔（`Bool`）类型仅适用 `EQUAL, NEQUAL` 指令。


### 11. 逻辑指令

实参需为布尔类型，返回值也是一个布尔值（`true` 或 `false`）。

指令值区间：`[113-116]`，4个。

```go
指令值  指令字      说明
-----------------------------------------------------------
113     BOTH        两个都为真（&&）
        // 逻辑AND，是否两个值都为 true。
        // 实参1：一个布尔值。
        // 实参2：一个布尔值。
        // 返回值：一个布尔值。
        // 例：
        // BOTH PASS  取栈顶两个值，都为真时通过。

114     EVERY       全部为真（类 &&）
        // 逻辑AND，是否全部成员都为 true。
        // 实参：一个布尔值集合。
        // 返回值：一个布尔值。
        // 例：
        // POPS[3] EVERY  栈顶3项打包，检查成员是否都为 true。
        // TOPS[0] EVERY  栈顶为一个空集，返回 true。

115     EITHER      两个中任一为真（||）
        // 逻辑OR，两者中是否有其一为 true。
        // 实参1：一个布尔值。
        // 实参2：一个布尔值。
        // 返回值：一个布尔值。
        // 例：
        // EITHER PASS  取栈顶两个值，任一为真时通过。

116     SOME(1)     部分为真（||, &&）
        // 逻辑OR，全部成员中是否至少 n 个为 true。
        // 附参：为真的最低数量（n）。
        // 实参：一个布尔值集合。
        // 返回值：一个布尔值。
        // 例：
        // SOME[2]  需2个以上为真（含2个）
        // SOME[1]  至少1个为真，较常用
        // SOME[0]  无条件为真。同空集之于EVERY
        // 例：
        // TOPS[0] SOME[1]  实参为空集，返回 false
        // TOPS[0] SOME[0]  返回 true
```


### 12. 模式指令

指令序列的模式匹配，用于验证目标脚本是否符合特定的逻辑序列。在排除掉可忽略的指令后，目标指令序列需与模式序列完整匹配。如果匹配失败，等同于验证失败。

一个模式序列通常称为一个模型。一个拥有广泛共识的模型可能会被预先发布在一笔管理者交易中供分享（作为 `GOTO` 目标）。

模式匹配很有用处，比如在链间兑换时确认对方的预支付脚本是否有效，在选举子链中对投票内容的格式做验证（以免选票无效），甚至由中间件执行匹配提取信息以执行链外的业务，实现无人工审核的自动化流程。

总的来说，模式匹配可以让某件事在*下一步具体行动前*得到合规性确认。

指令值区间：`[117-127]`，11个。

```go
指令值  指令字          说明
-----------------------------------------------------------
117     MODEL<>{}(1,2)  创建模式匹配区
        // 开启一个解析子环境，等待对实参字节序列执行模式匹配。
        // 附参1：可忽略指令清单长度，<>内为逗号分隔的指令列表。
        // 附参2：模式区长度，{}内包含了模式匹配序列。
        // 实参： 待测试的指令序列（Script）。
        // 返回值：一个切片或一个布尔值。
        // - 切片：  # 和 & 两个指令收集的值。如果匹配失败，抛出异常（验证失败）。
        // - 布尔值：当内部没有 # 和 & 取值时，返回匹配成功与否（失败不会抛出异常）。
        // 注意：
        // - 可忽略指令清单长度指占用的字节数，而非指令的个数。
        // - 不方便用名称表达的可忽略指令（如值指令），可用指令值表示。
        // - 忽略是指整个指令，包含附参、关联数据和其读取的实参区（如果需要读取）。
        // - 可忽略指令也可出现在模式区内，但会视为普通指令。
        // - 返回值有两种类型，所以实际上该指令有两种使用模式（验证或取值）。
        // 例：
        // 支付脚本：
        //      TOP FN_HASH160 DATA{<pkHash>}
        //      @TOP PRINT              // @TOP 为 PRINT 的实参区实参
        //      EQUAL PASS FN_CHECKSIG PASS
        // 模型：
        //      CODE{ ... }                         // 封装上面的脚本（指令值序列）
        //      MODEL<PRINT, INPUT, OUTPUT>         // PRINT 将被忽略
        //      {
        //          TOP FN_HASH160                  // 严格匹配（原样）
        //          DATA[20]{?}                     // 关联数据长度固定，内容任意
        //          #[4]                            // 取 DATA{} 关联数据。注：@TOP PRINT 已被忽略
        //          EQUAL PASS FN_CHECKSIG PASS     // 严格匹配（原样）
        //      }
        //      @SPREAD OUTPUT BUFDUMP  // 模型之外的普通代码。上面MODEL{}收集的数据已经自动入栈。
        // 说明：
        // - #[4] 指令提取了匹配目标的关联数据（公钥哈希）。
        // - 打印指令连同其 @TOP 实参取值被忽略，因此模式中看不到它们。
        // - 模式匹配结束后，MODEL指令返回了提取的公钥哈希。
        // 注：
        // 如果一个未知脚本匹配上面的模型，就说明它的支付逻辑正常。


// 以下为局部指令，仅在 MODEL{} 内有效。

118     #(1)        取值指示（指令）
        // 针对前一个指令匹配的目标，取目标的不同部分的值。
        // 附参：目标值标识。
        // 0001 - 指令本身。(1)
        // 0010 - 附参部分。(2)
        // 0100 - 关联数据。(4)
        // 1000 - 取值实参（如果需要，实参区或数据栈）。(8)
        // 可合并标识：
        // 0011 - 指令和附参。(3)
        // 0101 - 指令和关联数据。(5)
        // 0110 - 附参和关联数据。(6)
        // 0111 - 指令整体：指令、附参和关联数据。(7)
        // 1111 - 目标整体，含取值实参的值。(15)
        // 例：
        // MODEL<...> {
        //      DATA[32]{?} #4      // 提取前面 DATA 匹配目标的数据段。
        // }
        // #4 是 #[4] 的简写形式。
        // 注：
        // 提取的值会放入一个内部队列，作为MODEL最终的返回值。

119     ?           指令通配
        // 目标指令可为任意指令。含附参和关联数据，不含实参。
        // 例：
        // ?    当前目标位置为任意一个指令。

120     ?(1)        指令局部通配
        // 用跟随指令来和目标作比较，附参指定了通配的部分。
        // 附参：位置标识。
        // 0000 0001    关联数据任意。(1)
        // 1000 0000    第1个附参任意，其它附参严格匹配。(128)
        // 0100 0000    第2个附参任意，其它附参严格匹配。(64)
        // 0010 0000    第3个附参任意，其它附参严格匹配。(32)
        // 0001 0000    第4个附参任意，其它附参严格匹配。(16)
        // 0000 1000    第5个附参任意，其它附参严格匹配。(8)
        // 0000 0100    第6个附参任意，其它附参严格匹配。(4)
        // 0000 0010    第7个附参任意，其它附参严格匹配。(2)
        // 注：
        // 最多支持7个附参的通配标记，各个通配位可任意同时设置。
        //
        // 例：
        // ?[1] DATA[32]    跟随指令的关联数据任意（但必须为32字节长）。
        // ?1 DATA[32]      同上。
        // DATA[32]{?}      同上。阅读友好，由解析器处理实际位置。
        // TEXT[300]{?}     匹配300字节长任意文本。注：将被解析为 TEXT{}(2) 指令。
        // 注意：
        // DATA[?]{?}       附参任意，关联数据任意。匹配任意 DATA{} 值。
        // !Bytes           效果同上。匹配字节序列型任意值（! 见下）。
        //
        // 例：
        // ?128 INOUT[3]    首个附参任意，第二个附参确定。
        // INOUT[?, 3]      同上，可读性更好。
        // (?)              目标是一个表达式指令。
        // ({10} + (?))     目标表达式内该位置的子表达式内容任意。
        //
        // 例：
        // IF[60]{?}        匹配if指令，关联的语句块长60字节，内容不限。
        // IF[?]{?}         匹配一个if指令，长度和内容都任意。
        // IF[?]{           匹配一个if指令。子语法块正常延续测试。
        // IF{              同上。简化写法。
        //
        // 例：
        // @ ?1 DATA[32]    匹配实参取值，任意32字节序列。
        // @ DATA[32]{?}    同上。@ 之后的空格可选。
        // @ !Bytes         匹配字节序列取值指令（两个 DATA{}）。
        // $ POP            匹配 $POP 复合指令，空格可选。
        // $[?]             匹配局部域任意取值。
        // ?128 $           同上。

121     !{TYPE}(1)  类型匹配
        // 目标为特定类型的值指令。
        // 附参：类型名。
        // - Bool   布尔值
        // - Int    整数（7个）
        // - Byte   单字节
        // - Rune   单字符
        // - BigInt 大整数
        // - Float  浮点数（2个）
        // - Bytes  字节序列（2个）
        // - String 字符串（2个）
        // - RegExp 正则表达式（/.../）
        // - Date   日期/时间（TIME{}）
        // - Script 脚本代码（CODE{}）
        // 例：
        // !{Bool}  目标必须是布尔类型（true|false）。
        // !Bool    同上，可省略花括号。
        // !Bytes   匹配两个 DATA{} 指令。
        // !String  匹配两个 TEXT{} 指令。
        // !Script  匹配 CODE{} 指令。
        // !Int     匹配任意整数。
        // !Float   匹配任意浮点数。

122     !{}(~,~)    整数值范围匹配
        // 限定目标值在设定的范围之内，不包括上界值。
        // 附参1：下界值，变长整数。
        // 附参2：上界值，变长整数。
        // 例：
        // !{0, 1024} 限定目标值：0 ≦ n < 1024
        // !{0, 128}  限定目标值：0 ≦ n < 128（目标通常是 {}(1) 指令）。
        // 注：
        // - 整数由多个指令表达，范围匹配并不要求目标具体是哪个指令，
        //   只要值满足要求即可。
        // - 不支持大整数（BigInt）范围匹配。

123     !{}(8,8)    浮点数值范围匹配
        // 限定目标值在设定的范围之内，不包括上界值。
        // 附参1：下界值，8字节表达。
        // 附参2：上界值，8字节表达。
        // 例：
        // !{0, 1.0}  目标为小于1.0的任意正浮点数。
        // 注意：
        // 两个边界值必须至少有一个是浮点数表示，否则会被识别为整数范围。

124     RE{/.../gG}(1)  正则匹配
        // 对文本或字节序列目标执行正则表达式匹配。
        // 附参：此处正则式的内容长度。
        // 注意：
        // 不是检查目标是否为合规的正则表达式指令，而是对目标执行正则式匹配（MATCH），
        // 如果目标文本符合这里的正则式，则视为正确（通过）。
        // 匹配的结果值可以通过下面的 & 指令（依附关系）获取。
        //
        // 附注：
        // 没有前置RE和花括号的 /.../gG 才是指令自身匹配检查。

125     &(1)        取值指示（正则匹配）
        // 配合上面的 RE{/.../} 指令使用，针对其匹配目标，取匹配值或子匹配式的值。
        // 附参：正则表达式的取值序位。
        // 这是模式内除 # 指令外的第二个取值指令，它们的取值共同构成 MODEL{} 的返回值。
        // 注意本指令需要紧随其属主指令 RE{/.../} 之后。
        // 例：
        // MODEL<...> {
        //      RE{/(?i)[a-z]+/} &[0]   取目标字符串中匹配的单词
        // }
        // 例：
        // RE{/(?i)[a-zA-Z]+/} &0   效果同上。
        // RE{/Ver-(\d+)/} &[1]     提取主版本号（首个子表达式匹配项）
        // RE{/Ver-(\d+)/} &1       同上。简写形式
        // 注：
        // 上面示例中省略了上级封装指令 MODEL<>{}。
        //
        // 注记：
        // - 如果前面的 RE{/.../} 匹配没有成功，模式将不会通过，
        //   因此后面的本取值指令也就不会被执行了。
        // - 本指令为目标脚本的数据提取提供了一个便利，但目标必须首先得匹配。

126     ...         任意指令段匹配
        // 匹配任意指令序列（包括附参和数据）。
        // 通配只限于当前层级（同域），子语句块作为一个整体对待。
        // 贪婪匹配模式。
        // 例：
        // 目标脚本：
        //      SYS_TIME{Stamp} {<expireTime>} GT
        //      @TOP PRINT              // 1
        //      IF{
        //          @POP PRINT
        //      }
        //      TRUE
        //      IF{
        //          TEXT{Hello in IF}   // 2
        //          @TOP PRINT          // A
        //      }
        //      TEXT{done!}
        //      @TOP PRINT              // B
        //      @POPS[] NOP
        // 模型：
        // MODEL<>{
        //      SYS_TIME{Stamp}         // 换行没问题
        //      {<expireTime>} GT
        //      ...                     // 1
        //      IF{
        //          ...                 // 2
        //          @TOP PRINT          // A
        //      }
        //      TEXT{done!}
        //      @TOP PRINT              // B
        //      @POPS[] NOP            // 终点完整匹配
        // }
        // 1.
        // 第一个...匹配“@TOP PRINT IF{...} TRUE”。
        // 2.
        // 第二个...匹配「TEXT{Hello in IF}」，到A为止，不会跨层级到B。
        //
        // 模型：
        // MODEL<>{
        //      SYS_TIME{Stamp}
        //      {<expireTime>} GT
        //      ... IF{?}           // 匹配上面第二个IF（贪婪）
        //      ...                 // 剩余匹配
        // }
        // 注意：
        // 最后的...是必须的，这是匹配完整性要求（匹配到脚本结束）。
        //
        // 参考：
        // 如果将嵌套构造为树结构，是一个广度优先的测试。
        // 但不同域内的模式取值（#）依然按源码顺序（深度优先）收集。

127     （保留未用）
```


#### 附：模式匹配包含的内容

- **位置匹配**：滤除掉可以忽略的指令后，位置一一对应（位置记数不包含可忽略指令）。
- **指令匹配**：指令相同即为匹配。如果指令为值指令，则也隐含了类型匹配逻辑。
- **附参匹配**：在指令匹配的前提下，附参参与匹配。
- **数据匹配**：在指令匹配的前提下，指令关联的数据也参与匹配。
- **范围限定**：整数和浮点数的范围匹配，内部的细分类型被忽略。
- **类型匹配**：对目标的数据类型执行匹配，值任意。
- **正则匹配**：支持 `RE{/../}` 对文本目标进行正则匹配测试，并可通过 `&` 指令提取匹配结果。

> **注：**
> 流程类指令（`IF{}`、`SWITCH{}` 等）在有子内容匹配时，附参会被忽略。


### 13. 环境指令

脚本的运行处在一个逐层嵌套的环境里：`系统环境 > 交易域 > 校验域 > 脚本域 > 局部域`，其中前者是后者的父域。

1. **系统环境**。节点的运行时环境。包含节点能提供的一些系统级信息。
2. **交易域**。  一笔交易可包含多个输入和输出，这里可访问跨脚本的兄弟输入和输出。
3. **校验域**。  当前脚本的校验环境，包含 `GOTO` 跳转到的脚本的验证。
4. **脚本域**。  当前脚本的全局环境。`JUMP` 嵌入的子脚本与当前脚本共享此域，但 `GOTO` 跳转的脚本拥有自己的脚本域。
5. **局部域**。  当前脚本按语法块分层的存储区，包含顶层和嵌套子块都有。这些域是私有的，无法互访。

> **注：**<br>
> 只有当交易的输出（锁定）脚本需要作为新交易的输入时，它才需要被验证。<br>
> 证据中的输出（识别）脚本也是在客户端需要确认它（另一种意义上的输入）时，才需要验证。<br>


指令值区间：`[128-137]`，10个。

```go
指令值  指令字      说明
-----------------------------------------------------------
128     EVN{}(1)    环境变量取值
        // 附参：目标名称的标识值。
        // 返回值：目标成员值。
        // 书写时通常使用标准的名称而不是数值下标。
        //
        // 交易域：
        // 针对脚本所在的源交易。
        // - Height     理想块高度（按时间戳算）
        // - Time       理想块时间戳
        // - RealHeight 交易打包进的实际区块的高度
        // - TxID       交易ID
        // - Timestamp  交易时间戳
        // 例：
        // EVN{RealHeight} 获取当前输入所在交易的真实区块高度。
        //
        // 针对当前正在验证的交易。
        // 注：对于定义这些取值的脚本来说，是指将来花费它们的交易。
        // - InTotal    输入项总数
        // - InAmount   输入总金额
        // - OutTotal   输出项总数
        // - OutAmount  输出总金额
        //
        // 校验域：
        // 特定于当前脚本。
        // - InGoto     是否在 GOTO 跳转的脚本中
        // - InJump     是否在 JUMP 引入的脚本中
        // - Gotos      当前 GOTO 跳转计数
        // - Jumps      当前 Jump 嵌入计数
        //
        // 系统环境：
        // - BlockHeight 区块链当前最新高度
        // - BlockTime   当前最新区块创建的时间戳
        // - LimitStack  栈高度上限（256）
        // - LimitScope  局部变量域上限（128）
        // - ……

129     OUT{}(1,1)  输出项取值（交易域）
        // 针对当前交易的输出项集（即正在验证的交易）。
        // 可用于源锁定脚本限定其花费的目标（新的输出）。
        // 附参1：输出项序位（起始值0）。
        // 附参2：输出项中的成员的标识。
        // 返回值：目标成员值。
        // 成员：
        // - Amount      币金数量
        // - Receiver    接收者
        // - Description 凭信描述，适用凭信交易
        // - Count       凭信转移计数，适用同上
        // - Title       证据标题，适用证据交易
        // - Content     证据内容，适用同上
        // - Attachment  附件ID，适用凭信和证据交易
        // - Script      输出脚本自身
        // - Index       在输出集中的序位，从0开始
        // 例：
        //      OUT[0]{Amount}
        // 取当前在验交易中首个输出项的币金数量。
        // 这并不是一个在输出中实际存在的数值，而是验证节点推导计算出来的值。
        //
        // 注记：
        // 输出项序位仅用1字节表示，虽然一笔交易中的输出项可能更多。
        // 因此新交易的构造者可能需要对输出项的顺序做特意安排。
        // 注意：
        // 如果输入的锁定脚本中使用了本指令，则验证节点就需要详细查看交易的输出部分了。

130     IN{}(1)     输入项取值（校验域）
        // 大部分与上面输出项取值的字段名相同。
        // 因为输入项就是前阶交易中一个具体的输出项，所以无需序位附参。
        // 附参：取值的成员标识。
        // 返回值：目标成员值。
        // 成员：
        // - Amount      币金数量
        // - Receiver    接收者
        // - Description 凭信描述
        // - Count       凭信转移计数
        // - Title       证据标题
        // - Content     证据内容
        // - Attachment  附件ID
        // - Script      输入脚本自身
        // - Timestamp   源交易的创建时间戳
        // - Signsum     合法签名的数量
        // 注：
        // 当前交易的输入项实际上是上一笔交易的输出项。

131     INOUT{}(1,1) 输入项的兄弟输出项取值（系统环境）
        // 即输入项所在源交易的兄弟输出项取值，可建立不同输出之间的关联。
        // 附参1:目标输出项的序位（起始值0）。
        // 附参2:目标成员的标识。
        // 返回值：目标成员值。
        // 成员：
        // 参考前 OUT 指令。
        // 注记：
        // 这需要验证节点解析源交易的其它输出项，通常仅在有需要时才去做。

132     VAR(1)      全局变量取值（脚本域）
        // 附参：目标变量位置。
        // uint8 类型，最多支持256个变量。
        // 与局部域不同，此为变量逻辑，可被定位覆盖赋值。
        // 返回值：目标置位的值，单值。
        // 例：
        // @VAR[0] 取全局变量段里0号位的值添加到实参区。
        // VAR[10] 取全局变量段里第10号位置的值入栈。
        // 注：
        // 本指令属于脚本域，不跨GOTO。
        // JUMP指令跳转的脚本共享同样的脚本域，因此会相互影响。
        // 注记：
        // 实现可能是一个map[int]any，而不是一个切片。

133     SETVAR(1)   全局变量赋值（脚本域）
        // 在脚本域的全局变量区设置值，变量定位采用8位数值。
        // 可由上面的 VAR 指令读取。
        // 附参：变量位置值。
        // 实参：任意类型，单值。
        // 返回值：无。
        // 例：
        // {123} SETVAR[1]    将栈顶的值 123 存入全局变量段的第1号位置。
        // {1.5} SETVAR[255]  将浮点数 1.5 存入全局变量段的第255号位置。
        // $VAR[1]            读取上面存储的 123 添加到当前局部域。

134     MULSIG(1)   多重签名序位确认（校验域）
        // 目标序位的签名合法时返回true，否则返回false。
        // 附参：目标序位。即签名者序号，从0开始。
        // 返回值：布尔值。
        // 仅适用多重签名输入，在GOTO到的脚本中也可用。
        // 例：
        //      MULSIG[2]
        // 确认多重签名哈希列表中第3序位者参与签名。
        //      MULSIG[0] MULSIG[1] MULSIG[2] @POPS[3] SOME[2] PASS
        // 模拟2/3多重签名验证。

135     SOURCE      获取源脚本序列（脚本域）
        // 获取脚本的指令序列本身，主要用于模式匹配时用。
        // 起点：脚本头部，包括解锁部分。
        // 终点：当前指令位置（不含本指令）。
        // 注：
        // 在所有需要单独执行的代码片段内，头部都仅限于该片段范围。
        // 比如私有环境的 MAP、FILTER中，以及循环指令（EACH）内部等。

136     XFROM(1)    获取源脚本信息
        // 适用 GOTO 和 JUMP 的目标脚本，
        // 在其中获取跳转来源（从它过来）的脚本中的某些信息。
        // 成员：
        // - Script 源脚本指令序列。
        // - Offset 跳转/嵌入点在源脚本中的偏移位置。
        // - ...

137     （保留未用）
```


### 14. 工具指令

包含一些基础性并常用的功能性指令。

指令值区间：`[138-153]`，16个。

```go
指令值  指令字      说明
-----------------------------------------------------------
138     EVAL        子脚本执行
        // 将实参视为脚本指令值序列执行。
        // 实参：脚本指令值序列，Script类型。
        // 返回值：一个任意值。
        // 外部嵌入脚本的方式：
        // - 解锁脚本。公共逻辑，任何节点都需要执行。
        // - 缓存区导入。私有逻辑，需要部署的节点自行处理。
        // - GOTO/JUMP 引入，公共逻辑。
        // 提示：
        // 高消耗的脚本可能导致不受欢迎而被拉入黑名单。
        //
        // 安全性：
        // 系统可能会对嵌入的子脚本长度实施限制，如：
        // - 实参长度 < 256字节。
        // - 实参内禁止 EVAL（二次使用）。

139     COPY        切片复制
        // 复制成员到一个新的切片中，深度复制。
        // 实参：一个切片。
        // 返回值：一个全新切片。

140     MATCH(1)    正则匹配取值
        // 对字符串进行正则匹配，取匹配值或子匹配的值。
        // 附参：匹配方式（g|G|f|F|\0）。
        // 实参1：目标字符串。
        // 实参2：正则表达式模式。
        // 返回值：一个切片。G标记时为二维。
        // 附参含义：
        // - g  查找全部匹配，但仅限于正则式的完整匹配。结果是一个切片（类 JS:match）。
        // - G  查找全部匹配，包含其中的子匹配。结果是一个二维切片（类 JS:matchAll）。
        // - f  仅查找首个完整匹配，结果是一个字符串。
        // - F  仅查找首个匹配，但包含其中的子匹配，结果始终是一个切片。
        // - \0 零值，查找首个匹配，如果包含子匹配则返回一个切片，否则返回完整匹配字符串。
        // 各个标记是互斥的，同一时间只能有一个。
        // 例：
        // ... /(?i)[a-z]+/ MATCH{f}        获取首个完整匹配的片段（$0）
        // ... /(?i)[a-z]+/ MATCH[102]      同上，f 用码值表示
        // ... /(?i)Ver-(\d+)/ MATCH{g}     获取全部完整匹配，不包含子匹配项
        // ... /(?i)Ver-(\d+)/ MATCH[0]     获取首个匹配，因为存在子匹配，返回一个切片
        // ... /(?i)[a-z]+/ MATCH[0]        获取首个匹配，因为没有子匹配式，返回完整匹配串。

141     KEYVAL(1)   字典键值切分
        // 附参：取值标识。0 键+值；1 键；2 值。
        // 实参：一个字典。
        // 返回值：1-2个切片。
        // 返回的切片成员是没有固定顺序的（每次不一样）。
        // 默认返回键+值两个切片，两者的成员依然按下标位置对应。

142     SUBSTR(1)   字串截取
        // 附参：字符数量，uint8。
        // 实参1：一个字符串。
        // 实参2：起始字符位置。按字符计数，从0开始。
        // 返回值：一个子字符串。
        // 注：
        // 内部会正确解析出字符（rune），不论它有几个字节长。
        // 因此字串会是合法的UTF-8格式（如果原串合法）。

143     REPLACE     字串替换
        // 对目标字符串中匹配的部分进行替换。
        // 实参1：目标字符串
        // 实参2：替换匹配式（子串或正则表达式）
        // 实参3：替换串，可包含特殊标识（当匹配式为正则表达式时）。
        // 返回：一个新的字符串。

144     SRAND       切片成员顺序扰乱
        // 实参：一个切片。
        // 返回值：一个新切片。

145     RANDOM      获取一个随机数
        //

146-149 （保留未用）

150     RANGE(1)    创建连续数值序列
        // 步进值强制为1，创建一个递增的连续值序列。
        // 附参：序列长度（单元个数）。0值创建一个空切片。
        // 实参：起始值。整数或浮点数。
        // 返回值：一个整数或浮点数切片。
        // 例：
        // {10} RANGE[5]  // 生成 [10, 11, 12, 13, 14]。
        // {0} RANGE[]    // 生成 []，实参仅为占位（必需）。

151     RANGE       创建数值序列
        // 同上指令，但参数完整并全部由实参给定。
        // 实参1：起始值。整数或浮点数。
        // 实参2：步进值。整数或浮点数。
        // 实参3：序列长度（单元个数）。
        // 返回值：一个整数或浮点数切片。
        // 例：
        // @{10} @{10} @{5} RANGE  // 生成 [10, 20, 30, 40, 50]。
        // 注记：
        // 源码解析可观察RANGE是否携带中括号附参来分别。

152     （保留未用）

153     ANYSL       转换成 []any
        // 将某种类型的切片转换为 []any 类型。
        // 支持：
        // - Bytes      []byte
        // - Runes      []rune
        // - []Int      []int64
        // - []Float    []float64
        // - []String   []string
        // - []any      原样返回
        // 注：
        // 某些指令如DICT需要[]any数据，但实际可能是某种具体的切片，由此转换。
        // 当然也可通过 @SPREAD PUSH POPS[n] 指令序列构造。
```


### 15. 系统指令

执行系统级功能的指令。

指令值区间：`[154-159]`，6个。

```go
指令值  指令字          说明
-----------------------------------------------------------
154     SYS_TIME{}(1)   取全局时间对象的属性值
        // 全局时间对象是客户端真实的当前时间，只读。
        // 附参：目标属性的标识值。
        // 每一个属性被规划为固定的序号位置，但也包含标准的命名。
        // 如果采用字符串名称，需书写在花括号内。
        // 属性：
        // - Stamp      当前时间戳（毫秒）
        // - Year       年数（4位）
        // - Month      月次/年（1-12）
        // - YearDay    日次/年（1-365|366）
        // - Day        日次/月（1-31）
        // - WeekDay    日次/周（0-6）
        // - Hour       时数/日（0-23）
        // - Minute     分钟数/时（0-59）
        // - Second     秒数/分钟（0-59）
        // 例：
        // SYS_TIME{Stamp} 获取当前系统时间戳值入栈。
        // SYS_TIME[0]     同上（假设Stamp的序号为0）。

155     SYS_AWARD       兑奖验算
        // 检查当前交易所在区块之后240个区块的兑奖槽，计算奖金兑现。
        // 规则：
        //      确认数   兑现比例
        //      ----------------
        //      1        20%
        //      2        40%
        //      3        60%
        //      4        80%
        //      5        100%
        // 说明：
        // 因为是统计之后的区块的兑奖确认数，奖励必须超过一天才能兑现。
        // 所以当前铸造者需要分析前面240个区块的兑奖槽并计算-241号区块的奖金截留。
        // 用户能够取走的奖金和将要被截留的部分可能各自计算（但应互为契合）。

156-159 （保留未用）
```


### 16.函数指令

指令值区间：`[160-209]`，50个。


#### 基础函数集

定义一些常用的基础性函数。

> **注意：**
> 这里的指令书写按普通函数定义的方式，实参可从小括号内的文本体现出来，更为直观。

```go
指令值  函数名（参数序列） => 返回值类型
-----------------------------------------------------------
160     FN_HASH256( data Bytes ) => Bytes
        // 实参：任意字节序列。
        // 哈希计算，可用于哈希屏障保护。
        // 返回值：32字节长。

161     FN_HASH160( data Bytes ) => Bytes
        // 实参：任意字节序列。
        // 哈希计算，主要用于公钥的哈希计算。
        // 返回值：20字节长。
        // 注：
        // 字节形式的公钥哈希地址简称为公钥地址。

162     FN_BASE58( data Bytes ) => String
        // 实参：任意字节序列
        // 目标字节序列为编码为 Base58 字符串。

163     FN_BASE32N( data Bytes ) => String
        // 定制版Base32编码，
        // 实参：任意字节序列。
        // 后缀N表示定制数字 456789（标准格式为 123456）
        // 注记：
        // 标准的数字1在某些字体下，字形与字母I相似（易混淆）。

164     FN_ADDRESS( pbhash Bytes ) => String
        // 实参：公钥哈希地址。
        // 将字节格式的公钥哈希地址编码为文本地址（Base58），
        // 会前置专有标识，包含地址验证功能。
        // 注意：
        // 文本形式的公钥地址与字节格式的公钥地址是一样的，
        // 文本形式主要用于书写阅读，交易中则实为字节格式的哈希序列。
        //
        // 编码：
        // 1. 对公钥地址再执行一次哈希运算，取末尾4字节为校验码。
        // 2. 在公钥地址之后附上校验码，编码为 Base58 形式，即为公钥的文本地址。
        // 校验：
        // 1. 将公钥的文本地址解码为字节序列。
        // 2. 截取序列的最后4字节为校验码，前段即为公钥地址。
        // 3. 对前段的公钥地址执行一次哈希，取末尾4字节与校验码对比，相同则地址合法。
        //
        // 前缀字符参考：
        // - 1  普通账户地址，单签名。
        // - 2  1/2签名账户地址。
        // - 3  2/3签名账户地址专属。
        // - 0  定制多重签名账户地址（非2和3类型）。

165     FN_CHECKSIG( sig, pubkey Bytes ) => Bool
        // 单签名验证。
        // 实参：（签名，公钥）

166     FN_MCHECKSIG( sig Bytes, n, t byte, pubkeys, restpkhs []Bytes ) => Bool
        // 多重签名验证。
        // 实参：（签名, n/t配比, 公钥集, 剩余公钥地址集）

167-199 （保留未用）

200     FN_PRINTF( fmt, val, ... ) => nil
        // 格式化打印（格式化串，实参1，实参2，...），同 go:fmt.Printf。
        // 实参：不定数量。

201-207 （保留未用）
```


#### 扩展函数集

两个扩展类指令引入更多可能需要的函数，空间已十分可观。

```go
指令值  指令字          说明
-----------------------------------------------------------
208     FN_A(1)         基础扩展（1字节空间）
        // 1字节的附参可包含256个扩展函数。

209     FN_B(2)         高级扩展（2字节空间）
        // 2字节的附参可包含64k个扩展函数。
```


### 17.模块指令

模块的成员以标准的名称书写在花括号内，附参多为1个字节，用于索引成员函数。

通常，模块如果需要创建一个表示自身的对象，应由首个成员 `Create` 实施。作为约定，如果其它成员函数需要使用该对象，应作为首个参数传入。

指令值区间：`[210-249]`，40个。

```go
指令值  指令字          说明
-----------------------------------------------------------
210     MO_RE{}(1)      正则表达式模块
        // 处理正则表达式对象，对象作为首个参数传入。
        // 可由 /.../ 指令创建，或由 REGEXP 指令转换而来。
        // 方法：
        // - （待定）

211     MO_DATE{}(1)    日期对象模块
        // 处理日期/时间对象，对象作为首个参数传入。
        // 可由 TIME{} 指令创建，或由 DATE 指令转换而来。
        // 方法：
        // - （待定）

212     MO_MATH{}(1)    数学运算模块
        // 例：
        // MO_MATH{Abs} 计算实参的绝对值。
        // 成员：
        // - Abs    绝对值：|-4| => 4
        // - Pow    幂乘值：x**y
        // ...

213     MO_CRYPT{}(1)   加密运算模块
        // 对称加密：
        //
        // 非对称加密：
        //

214-248 （保留未用）

249     MO_X(1)         标准扩展引用
        // 1字节支持扩展到256个模块，似已足够。
        // 如需更多模块支持，可以使用扩展区指令（EX_BASE 或 EX_BASE2）。
```


### 18. 扩展指令

最后的8个指令空间位用于扩展指令区。

指令的扩展籍由附参实现，主要包含了2个预置的引用指令（`EX_BASE`，`EX_BASE2`）：附参定位了扩展的指令本身，而该扩展指令是一个完整的逻辑，可以包含其自身的附参。

这种扩展方式实际上是一种 **附参递进** 的逻辑，理论上可以无限递进、深层嵌套（很难看，不过实际上也用不着）。

指令值区间：`[250-255]`，6个。

```go
指令值  指令字          说明
-----------------------------------------------------------
250     EX_BASE(1)      基础扩展引用（1字节空间）
        // 1字节的附参可包含256个扩展指令。

251     EX_BASE2(2)     基础扩展引用（2字节空间）
        // 2字节的附参可包含64k个扩展指令。

252     （保留未用）

253     EX_PRIV(1)      私有扩展引用（1字节空间）
        // 私有范畴，公共节点简单忽略（不执行）。
        // 通常由有特定需求的应用使用。
        // 注：
        // 如果在模式语句块内使用，则遵循正常的模式匹配逻辑，
        // 这不会导致指令运行。

254     EX_PRIV2(2)     私有扩展引用（2字节空间）
        // 同上。较大扩展空间容量（64k）。

255     （系统保留）
```


-------------------------------------------------------------------------------

上一篇：[脚本系统设计](5.脚本系统设计.md)<br>
下一篇：[附1：组队校验](附1.组队校验.md)<br>
